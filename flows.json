[
    {
        "id": "190ed3e96d0709a5",
        "type": "tab",
        "label": "ADC2",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "4f1c58c90aef2801",
        "type": "tab",
        "label": "ADC_8CH",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "0a1446a2506c6a05",
        "type": "tab",
        "label": "calculo flujo optimizado",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "663b1dbab4a22bc2",
        "type": "tab",
        "label": "FIVERR",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "cf449ce1322fd8eb",
        "type": "tab",
        "label": "T. Principal RTU",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7bdaf3fb66ecd941",
        "type": "tab",
        "label": "T. Principal RTU",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "79b057876d37bdc0",
        "type": "tab",
        "label": "ADC4",
        "disabled": true,
        "info": "ADC para tempertura de intercambiadores\r\nSIO-MB08THMS\r\nTemperature Input Module: thermocouple, 8-channel in",
        "env": []
    },
    {
        "id": "af01d920764bfaad",
        "type": "tab",
        "label": "flujo optimizado 1.1",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "1b6aa974e2ca303d",
        "type": "subflow",
        "name": "Calcular Volumen y Enviar",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 60,
                "wires": [
                    {
                        "id": "bc34e8077dafa34c"
                    }
                ]
            }
        ],
        "out": [],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "7ac8f4b3a29c864f",
        "type": "mqtt-broker",
        "name": "MN-1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "bb61bb0c49cb82b4",
        "type": "mqtt-broker",
        "name": "MN-9",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "aeb8c7546d28ce5c",
        "type": "mqtt-broker",
        "name": "MN-7",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "661d09df777a5259",
        "type": "modbus-client",
        "name": "pruebas",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.75",
        "tcpPort": "502",
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB0",
        "serialType": "RTU",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "3f690bb5a526a246",
        "type": "ui-group",
        "name": "Tablero Alimentaci√≥n Sistema",
        "page": "53bbd3554f5781e9",
        "width": "12",
        "height": "2",
        "order": 3,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "a1b3d7fc83d5c6f6",
        "type": "Stackhero-InfluxDB-v2-Server",
        "name": "",
        "host": "influxdb2",
        "port": "8086",
        "tls": false
    },
    {
        "id": "53bbd3554f5781e9",
        "type": "ui-page",
        "name": "Tablero principal",
        "ui": "bc1023506614f084",
        "path": "/pageN",
        "icon": "home",
        "layout": "grid",
        "theme": "60ac3cbdefc9f2e1",
        "order": 1,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "bc1023506614f084",
        "type": "ui-base",
        "name": "Valores sensores",
        "path": "/dashboard",
        "includeClientData": true,
        "acceptsClientConfig": [
            "ui-notification",
            "ui-control"
        ],
        "showPathInSidebar": false,
        "navigationStyle": "default"
    },
    {
        "id": "60ac3cbdefc9f2e1",
        "type": "ui-theme",
        "name": "Default Theme",
        "colors": {
            "surface": "#ffffff",
            "primary": "#0094ce",
            "bgPage": "#eeeeee",
            "groupBg": "#ffffff",
            "groupOutline": "#cccccc"
        },
        "sizes": {
            "pagePadding": "12px",
            "groupGap": "12px",
            "groupBorderRadius": "4px",
            "widgetGap": "14px"
        }
    },
    {
        "id": "90c50477d9bdd042",
        "type": "ui-group",
        "name": "Tablero HCD",
        "page": "53bbd3554f5781e9",
        "width": "12",
        "height": "1",
        "order": 4,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "74e31200f882aea8",
        "type": "mqtt-broker",
        "name": "MN-4",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "714e095421e2277c",
        "type": "mqtt-broker",
        "name": "MN-06A",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "3e658c694e790b36",
        "type": "mqtt-broker",
        "name": "MN-6B",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "7010d93871a46530",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MF-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "0274315f4b847684",
        "type": "modbus-client",
        "name": "VOLISON_4CH",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.202",
        "tcpPort": "502",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB1",
        "serialType": "RTU",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "1514c5b7f877eca4",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MN-2.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "32c32aed21b2158b",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MF-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "e11805043013252c",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MP-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "656e301905d6c960",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-2.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "2949ed73ecfc0cf4",
        "type": "ui-group",
        "name": "Calentador de carga",
        "page": "53bbd3554f5781e9",
        "width": "3",
        "height": "1",
        "order": 1,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "ef01f57616a5ac26",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-2.2",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "27e2c5634b9f1073",
        "type": "modbus-client",
        "name": "Waveshare Modbus RTU",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.201",
        "tcpPort": "503",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "f344d91a44765e3a",
        "type": "mqtt-broker",
        "name": "flujocope",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "d7770bcbe96d749b",
        "type": "modbus-client",
        "name": "VOLISON_4CH",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.202",
        "tcpPort": "502",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB1",
        "serialType": "RTU",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "a4711ffb9fb91852",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MN-2.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "2d1e2d95cac9f303",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MF-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "4bcf0b14a189ae2d",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MP-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "d53c11d64889806f",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-2.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "9fa25027cf22c16b",
        "type": "ui-group",
        "name": "Calentador de carga",
        "page": "53bbd3554f5781e9",
        "width": "3",
        "height": "1",
        "order": 1,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "5062027c5a82285c",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-2.2",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "e3dc711be64f6be4",
        "type": "modbus-client",
        "name": "Waveshare Modbus RTU",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.201",
        "tcpPort": "503",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "aa49ccb7cd13b90a",
        "type": "modbus-client",
        "name": "ADC4",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.105",
        "tcpPort": "502",
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "9dee42aba81f471c",
        "type": "ui-group",
        "name": "Intercambiadores",
        "page": "53bbd3554f5781e9",
        "width": "4",
        "height": "1",
        "order": 3,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "9c8d857bf03439f0",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-4.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "374271799f2080bb",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-4.2",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "f9afc8173d9cc7da",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-4.3",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "6a688c0112ac638b",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-4.4",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "1ae19fd8375bb2f1",
        "type": "ui_group",
        "name": "Alertas",
        "tab": "8e0e1205ec7a33cb",
        "order": 1,
        "disp": true,
        "width": "6",
        "collapse": false,
        "className": ""
    },
    {
        "id": "8e0e1205ec7a33cb",
        "type": "ui_tab",
        "name": "Home",
        "icon": "dashboard",
        "disabled": false,
        "hidden": false
    },
    {
        "id": "a62d09e38ce8a3be",
        "type": "ui_base",
        "theme": {
            "name": "theme-light",
            "lightTheme": {
                "default": "#0094CE",
                "baseColor": "#0094CE",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": false
            },
            "darkTheme": {
                "default": "#097479",
                "baseColor": "#097479",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": false
            },
            "customTheme": {
                "name": "Untitled Theme 1",
                "default": "#4B7930",
                "baseColor": "#4B7930",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
            },
            "themeState": {
                "base-color": {
                    "default": "#0094CE",
                    "value": "#0094CE",
                    "edited": false
                },
                "page-titlebar-backgroundColor": {
                    "value": "#0094CE",
                    "edited": false
                },
                "page-backgroundColor": {
                    "value": "#fafafa",
                    "edited": false
                },
                "page-sidebar-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-textColor": {
                    "value": "#1bbfff",
                    "edited": false
                },
                "group-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "widget-textColor": {
                    "value": "#111111",
                    "edited": false
                },
                "widget-backgroundColor": {
                    "value": "#0094ce",
                    "edited": false
                },
                "widget-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "base-font": {
                    "value": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
                }
            },
            "angularTheme": {
                "primary": "indigo",
                "accents": "blue",
                "warn": "red",
                "background": "grey",
                "palette": "light"
            }
        },
        "site": {
            "name": "Node-RED Dashboard",
            "hideToolbar": "false",
            "allowSwipe": "false",
            "lockMenu": "false",
            "allowTempTheme": "true",
            "dateFormat": "DD/MM/YYYY",
            "sizes": {
                "sx": 48,
                "sy": 48,
                "gx": 6,
                "gy": 6,
                "cx": 6,
                "cy": 6,
                "px": 0,
                "py": 0
            }
        }
    },
    {
        "id": "bc34e8077dafa34c",
        "type": "function",
        "z": "1b6aa974e2ca303d",
        "name": "Calcular Volumen",
        "func": "const sensorConfig = {\n    'read_ADC2_AI1': { maxLitros: 19000, equipo_id: 'FA-09', sensor_id: 'MN-9', mqttBroker: 'bb61bb0c49cb82b4' },\n    'read_ADC2_AI2': { maxLitros: 115500, equipo_id: 'FA-01', sensor_id: 'MN-1', mqttBroker: '7ac8f4b3a29c864f' },\n    'read_ADC2_AI3': { maxLitros: 50000, equipo_id: 'FA-XX', sensor_id: 'MN-XX', mqttBroker: 'mqttBrokerID' },\n    'read_ADC2_AI4': { maxLitros: 30000, equipo_id: 'FA-YY', sensor_id: 'MN-YY', mqttBroker: 'mqttBrokerID' }\n};\n\nconst config = sensorConfig[msg.topic];\nconst valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * config.maxLitros;\nmsg.payload = Math.round(valorLitros);\nmsg.equipo_id = config.equipo_id;\nmsg.sensor_id = config.sensor_id;\nmsg.mqttBroker = config.mqttBroker;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 60,
        "wires": [
            [
                "5f1828bf7e42131a",
                "ab4c022dca8a290b",
                "b493823a86913ab5"
            ]
        ]
    },
    {
        "id": "5f1828bf7e42131a",
        "type": "mqtt out",
        "z": "1b6aa974e2ca303d",
        "name": "Enviar a MQTT",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "broker": "",
        "x": 480,
        "y": 40,
        "wires": []
    },
    {
        "id": "ab4c022dca8a290b",
        "type": "function",
        "z": "1b6aa974e2ca303d",
        "name": "Formatear para UI",
        "func": "msg.payload = msg.payload;\nmsg.topic = `Nivel ${msg.equipo_id}`;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 80,
        "wires": [
            [
                "36a9c45880b69202"
            ]
        ]
    },
    {
        "id": "36a9c45880b69202",
        "type": "ui_gauge",
        "z": "1b6aa974e2ca303d",
        "name": "Gauge de Volumen",
        "group": "3f690bb5a526a246",
        "order": 1,
        "width": "6",
        "height": "4",
        "gtype": "gage",
        "title": "{{msg.topic}}",
        "label": "Litros",
        "format": "{{value}}",
        "min": 0,
        "max": "100000",
        "colors": [
            "#00b500",
            "#e6e600",
            "#ca3838"
        ],
        "seg1": "",
        "seg2": "",
        "diff": false,
        "className": "",
        "x": 670,
        "y": 80,
        "wires": []
    },
    {
        "id": "b493823a86913ab5",
        "type": "function",
        "z": "1b6aa974e2ca303d",
        "name": "Enviar a InfluxDB",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: msg.sensor_id,\n                equipo_id: msg.equipo_id,\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 120,
        "wires": [
            [
                "ec9823e16410f948"
            ]
        ]
    },
    {
        "id": "ec9823e16410f948",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "1b6aa974e2ca303d",
        "server": "a1b3d7fc83d5c6f6",
        "name": "InfluxDB",
        "x": 670,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "0c9c4c6ccd5f1680",
        "type": "change",
        "z": "190ed3e96d0709a5",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 800,
        "y": 520,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "a1d380aff2236a21",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic === \"\") || (msg.topic === null) || (msg.topic === undefined)) {\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Topic missing\" });\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current > 0) && (current % resendinterval === 0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg !== undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state === 1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\", []);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i = queue.length - 1; i >= 0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i, 1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\", queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length > 0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0, 1);\n        context.set(\"queue\", queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return [newmsg, null, null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n\n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 700,
        "wires": [
            [
                "935f6caa0c13c143"
            ],
            [],
            [
                "55b26ddfc0cc83ba",
                "9f254561809fe947"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "55b26ddfc0cc83ba",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 780,
        "wires": [
            [
                "2f6892ae26582cc0"
            ]
        ]
    },
    {
        "id": "5c1e21e0692f309f",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 520,
        "y": 780,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "69b686e91740cea5",
        "type": "switch",
        "z": "190ed3e96d0709a5",
        "name": "ADC2 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC2_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI4",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1180,
        "y": 680,
        "wires": [
            [
                "58303efc8fb8844e",
                "358a6d7f67ffce8f"
            ],
            [
                "577bce23d5b23116"
            ],
            [
                "73e1e81e7546e4fb"
            ],
            []
        ]
    },
    {
        "id": "75e2840ee8295271",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 700,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "d24d58116973bc71",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 740,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "577bce23d5b23116",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "calc_vol_FA-01",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (115500 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 560,
        "wires": [
            [
                "168aaf88f24c3fe4",
                "b4188b3a422f8bef",
                "e405700295bd27f7",
                "fcbfd2b58ba9ac83",
                "a77fa9701c726221"
            ],
            []
        ]
    },
    {
        "id": "50d885b438d788be",
        "type": "mqtt out",
        "z": "190ed3e96d0709a5",
        "name": "mqtt_tb_MN-1",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "7ac8f4b3a29c864f",
        "x": 1780,
        "y": 580,
        "wires": []
    },
    {
        "id": "168aaf88f24c3fe4",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 580,
        "wires": [
            [
                "50d885b438d788be"
            ]
        ]
    },
    {
        "id": "b4188b3a422f8bef",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 520,
        "wires": [
            [
                "55044db629aca6f4"
            ]
        ]
    },
    {
        "id": "e405700295bd27f7",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "vol_FA-01",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 560,
        "wires": []
    },
    {
        "id": "358a6d7f67ffce8f",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "calc_vol_FA-09",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (19000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 660,
        "wires": [
            [
                "c1ca46f6bb75b7dd",
                "83a76faa5a6226ef",
                "1765a68bea6d7b05",
                "d250c11d6dec42a9"
            ],
            []
        ]
    },
    {
        "id": "e5568dbdb4388bd7",
        "type": "mqtt out",
        "z": "190ed3e96d0709a5",
        "name": "mqtt_tb_MN-9",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "bb61bb0c49cb82b4",
        "x": 1780,
        "y": 680,
        "wires": []
    },
    {
        "id": "c1ca46f6bb75b7dd",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 680,
        "wires": [
            [
                "e5568dbdb4388bd7"
            ]
        ]
    },
    {
        "id": "83a76faa5a6226ef",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 640,
        "wires": [
            [
                "409147dccbfefd7e"
            ]
        ]
    },
    {
        "id": "1765a68bea6d7b05",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "vol_FA-09",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 660,
        "wires": []
    },
    {
        "id": "73e1e81e7546e4fb",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "calc_vol_FA-07",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (200000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 780,
        "wires": [
            [
                "1925a962bbeb0bdd",
                "ab6e924ec584b66b",
                "72632dd37f42d210",
                "d68d9ad9e6ba918a"
            ],
            []
        ]
    },
    {
        "id": "c22c16254362436d",
        "type": "mqtt out",
        "z": "190ed3e96d0709a5",
        "name": "mqtt_tb_MN-7",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "aeb8c7546d28ce5c",
        "x": 1780,
        "y": 780,
        "wires": []
    },
    {
        "id": "1925a962bbeb0bdd",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 780,
        "wires": [
            [
                "c22c16254362436d"
            ]
        ]
    },
    {
        "id": "ab6e924ec584b66b",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 740,
        "wires": [
            [
                "ad4fc4580773a583"
            ]
        ]
    },
    {
        "id": "72632dd37f42d210",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "vol_FA-07",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1960,
        "y": 760,
        "wires": []
    },
    {
        "id": "935f6caa0c13c143",
        "type": "modbus-flex-getter",
        "z": "190ed3e96d0709a5",
        "name": "ADC2",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": false,
        "logIOActivities": false,
        "server": "661d09df777a5259",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 910,
        "y": 660,
        "wires": [
            [
                "0c9c4c6ccd5f1680",
                "69b686e91740cea5"
            ],
            []
        ]
    },
    {
        "id": "55044db629aca6f4",
        "type": "ui-chart",
        "z": "190ed3e96d0709a5",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-01",
        "label": "Volumen FA-01",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "105000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1800,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "409147dccbfefd7e",
        "type": "ui-chart",
        "z": "190ed3e96d0709a5",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-09",
        "label": "Volumen FA-09",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "20000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1800,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "ad4fc4580773a583",
        "type": "ui-chart",
        "z": "190ed3e96d0709a5",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-07",
        "label": "Volumen FA-07",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "200000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1800,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "fcbfd2b58ba9ac83",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-1', \n                equipo_id: 'FA-01', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1950,
        "y": 480,
        "wires": [
            [
                "c2f402fd7de228b2"
            ]
        ]
    },
    {
        "id": "c2f402fd7de228b2",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "190ed3e96d0709a5",
        "server": "a1b3d7fc83d5c6f6",
        "name": "DB",
        "x": 2190,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "d250c11d6dec42a9",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-9', \n                equipo_id: 'FA-09', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 620,
        "wires": [
            [
                "c2f402fd7de228b2"
            ]
        ]
    },
    {
        "id": "d68d9ad9e6ba918a",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-7', \n                equipo_id: 'FA-07', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 720,
        "wires": [
            [
                "c2f402fd7de228b2"
            ]
        ]
    },
    {
        "id": "a77fa9701c726221",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "debug 42",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1600,
        "y": 440,
        "wires": []
    },
    {
        "id": "58303efc8fb8844e",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "debug 43",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 500,
        "wires": []
    },
    {
        "id": "e88437c06ce5e178",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 620,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "7ff3dc8119cca4d3",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 660,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "1e8be9ee0af07cce",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 500,
        "y": 580,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "2f776b033e7cd327",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 540,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "fb726970df3a5a11",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 470,
        "y": 360,
        "wires": [
            [
                "0c548bd3de817c51"
            ]
        ]
    },
    {
        "id": "88b118ad8adef70d",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 470,
        "y": 400,
        "wires": [
            [
                "23cbf47d22124f5a"
            ]
        ]
    },
    {
        "id": "0c548bd3de817c51",
        "type": "change",
        "z": "190ed3e96d0709a5",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 650,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "23cbf47d22124f5a",
        "type": "change",
        "z": "190ed3e96d0709a5",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 670,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "a82d87f1056b77c2",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "reset",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 500,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "9f254561809fe947",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "Status Queue",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 920,
        "y": 820,
        "wires": []
    },
    {
        "id": "2f6892ae26582cc0",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "update log",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1090,
        "y": 780,
        "wires": []
    },
    {
        "id": "ab77e3b0be16441c",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI0",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":40,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 420,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "fd46ad6b8843e95e",
        "type": "change",
        "z": "4f1c58c90aef2801",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 560,
        "y": 440,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "e0f9ab2ec51ce602",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic === \"\") || (msg.topic === null) || (msg.topic === undefined)) {\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Topic missing\" });\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current > 0) && (current % resendinterval === 0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg !== undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state === 1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\", []);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i = queue.length - 1; i >= 0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i, 1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\", queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length > 0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0, 1);\n        context.set(\"queue\", queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return [newmsg, null, null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n\n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 560,
        "wires": [
            [
                "70471518d5fa5df4"
            ],
            [],
            [
                "8050baee79313da6",
                "ca50c8da91087b3c"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "8050baee79313da6",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 600,
        "wires": [
            [
                "dafbc58d04cb9995"
            ]
        ]
    },
    {
        "id": "a471b5f442e7dd47",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 700,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "a9f7ca731edbcb8b",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI1",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":41,\"quantity\":1}",
        "payloadType": "json",
        "x": 210,
        "y": 460,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "8e1884802ce9f6c0",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI2",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":42,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 500,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "073779b13bf18f48",
        "type": "switch",
        "z": "4f1c58c90aef2801",
        "name": "ADC3 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC3_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI5",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI6",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI7",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 8,
        "x": 960,
        "y": 440,
        "wires": [
            [
                "c7621a1f1897c3a5"
            ],
            [
                "83b40c324c670d95"
            ],
            [
                "08216224f5fd3608"
            ],
            [],
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "469167ab978a5033",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI3",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":43,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "05689b7dff66f908",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI4",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":44,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "b431110895da16a1",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI5",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI5",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":45,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "ecdc72f09b9ececa",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI6",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI6",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":46,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "c7621a1f1897c3a5",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "calc_vol_FA-04",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (65000 - 3200);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 320,
        "wires": [
            [
                "557237e248b7dc62",
                "ac3a9923480b6a67",
                "5525db57403cc012",
                "391fb7592ef9f2b2"
            ],
            []
        ]
    },
    {
        "id": "557237e248b7dc62",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 240,
        "wires": [
            [
                "d55dae7b3a90f13d"
            ]
        ]
    },
    {
        "id": "ac3a9923480b6a67",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 200,
        "wires": [
            [
                "06c43dbe5b22b8a6"
            ]
        ]
    },
    {
        "id": "5525db57403cc012",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "vol_FA-04",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1500,
        "y": 320,
        "wires": []
    },
    {
        "id": "08216224f5fd3608",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "calc_vol_FA-06A",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (51600 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 400,
        "wires": [
            [
                "80759972356d7f6a",
                "ab5c669f3b6e56e3",
                "8317da5af486e3b8",
                "dcc7e839ba2a5567"
            ],
            []
        ]
    },
    {
        "id": "80759972356d7f6a",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 400,
        "wires": [
            [
                "f5299b1650911717"
            ]
        ]
    },
    {
        "id": "ab5c669f3b6e56e3",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 360,
        "wires": [
            [
                "9717f724ef7d6c9f"
            ]
        ]
    },
    {
        "id": "8317da5af486e3b8",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "vol_FA-06A",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 480,
        "wires": []
    },
    {
        "id": "83b40c324c670d95",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "calc_vol_FA-06B",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (94100 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 540,
        "wires": [
            [
                "c80a6e94848ba081",
                "02b9dcee13d97f5a",
                "3cf04a5870f50ee4",
                "4bc7cfceb55f96bb"
            ],
            []
        ]
    },
    {
        "id": "c80a6e94848ba081",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 580,
        "wires": [
            [
                "7047b915d06ac299"
            ]
        ]
    },
    {
        "id": "02b9dcee13d97f5a",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 540,
        "wires": [
            [
                "57403451691dd1ad"
            ]
        ]
    },
    {
        "id": "3cf04a5870f50ee4",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "vol_FA-06B",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 660,
        "wires": []
    },
    {
        "id": "70471518d5fa5df4",
        "type": "modbus-flex-getter",
        "z": "4f1c58c90aef2801",
        "name": "ADC3",
        "showStatusActivities": true,
        "showErrors": true,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "661d09df777a5259",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 690,
        "y": 540,
        "wires": [
            [
                "fd46ad6b8843e95e",
                "073779b13bf18f48"
            ],
            []
        ]
    },
    {
        "id": "06c43dbe5b22b8a6",
        "type": "ui-chart",
        "z": "4f1c58c90aef2801",
        "group": "90c50477d9bdd042",
        "name": "Volumen FA-04",
        "label": "Volumen FA-04",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "63000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1640,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "9717f724ef7d6c9f",
        "type": "ui-chart",
        "z": "4f1c58c90aef2801",
        "group": "90c50477d9bdd042",
        "name": "Volumen FA-06A",
        "label": "Volumen FA-06A",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "54000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1650,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "57403451691dd1ad",
        "type": "ui-chart",
        "z": "4f1c58c90aef2801",
        "group": "90c50477d9bdd042",
        "name": "Volumen FA-06B",
        "label": "Volumen FA-06B",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "93000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1650,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "391fb7592ef9f2b2",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-4',\n                equipo_id: 'FA-04',\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 280,
        "wires": [
            [
                "0e9bc527bc20300f"
            ]
        ]
    },
    {
        "id": "0e9bc527bc20300f",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "4f1c58c90aef2801",
        "server": "a1b3d7fc83d5c6f6",
        "name": "DB",
        "x": 1950,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "dcc7e839ba2a5567",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-6A',\n                equipo_id: 'FA-06A',\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 440,
        "wires": [
            [
                "0e9bc527bc20300f"
            ]
        ]
    },
    {
        "id": "4bc7cfceb55f96bb",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-6B',\n                equipo_id: 'FA-06B',\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 620,
        "wires": [
            [
                "0e9bc527bc20300f"
            ]
        ]
    },
    {
        "id": "d55dae7b3a90f13d",
        "type": "mqtt out",
        "z": "4f1c58c90aef2801",
        "name": "mqtt_tb_MN-4",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "74e31200f882aea8",
        "x": 1640,
        "y": 240,
        "wires": []
    },
    {
        "id": "f5299b1650911717",
        "type": "mqtt out",
        "z": "4f1c58c90aef2801",
        "name": "mqtt_tb_MN-6A",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "714e095421e2277c",
        "x": 1660,
        "y": 400,
        "wires": []
    },
    {
        "id": "7047b915d06ac299",
        "type": "mqtt out",
        "z": "4f1c58c90aef2801",
        "name": "mqtt_tb_MN-6B",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "3e658c694e790b36",
        "x": 1660,
        "y": 580,
        "wires": []
    },
    {
        "id": "1c7ded7911537f86",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "Watchdog Check",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "watchdog",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 820,
        "wires": [
            [
                "67c7a396cf4426e5"
            ]
        ]
    },
    {
        "id": "67c7a396cf4426e5",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "Check Connection",
        "func": "const lastUpdate = context.get('lastUpdate') || 0;\nconst now = Date.now();\nconst threshold = 60000; // 60 seconds\n\nif (now - lastUpdate > threshold) {\n    // Connection lost\n    return [null, {payload: 'reset'}];\n} else {\n    // Connection OK\n    return [{payload: 'OK'}, null];\n}\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 820,
        "wires": [
            [],
            [
                "544ccd9ff96b0984"
            ]
        ]
    },
    {
        "id": "544ccd9ff96b0984",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "Reset Modbus",
        "func": "// This function will attempt to reset the Modbus client\n// You may need to adjust this based on your specific Modbus client configuration\nconst modbusConfig = global.get('modbus-config');\nif (modbusConfig) {\n    modbusConfig.reconnect();\n    node.status({fill:\"yellow\",shape:\"ring\",text:\"Reconnecting...\"});\n    return {payload: \"Attempting to reconnect Modbus client\"};\n} else {\n    node.status({fill:\"red\",shape:\"ring\",text:\"No Modbus config found\"});\n    return {payload: \"Error: No Modbus configuration found\"};\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "e76302d7022b3b33",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "reset",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 300,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "2ed1d18b792632d9",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 340,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "5f35fa7167a15493",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 220,
        "y": 380,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "ca50c8da91087b3c",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "Status Queue",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 640,
        "wires": []
    },
    {
        "id": "dafbc58d04cb9995",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "update log",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 810,
        "y": 600,
        "wires": []
    },
    {
        "id": "7346e461e4b1c18f",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor num√©rico\nreturn msg;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 300,
        "wires": [
            [
                "66ff9460a01c6324"
            ],
            []
        ]
    },
    {
        "id": "66ff9460a01c6324",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no est√° disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 280,
        "wires": [
            [
                "5a92dc2c750f0ec5"
            ]
        ]
    },
    {
        "id": "5a92dc2c750f0ec5",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Flow Calculation Node",
        "func": "const RELLENANDO_KEY = \"rellenando\";\nconst FLUJOS_RECIENTES_KEY = \"flujosRecientes\";\nconst COLA_VACIADO_KEY = \"colaVaciado\";\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0) {\n        return Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nfunction estaRellenando(cola) {\n    if (cola.length < 2) return false;\n    const cambioVolumen = cola[cola.length - 1].volumen - cola[0].volumen;\n    return cambioVolumen > 150;\n}\n\nfunction obtenerPromedioFlujo(flujosRecientes) {\n    if (flujosRecientes.length === 0) return 0;\n    const suma = flujosRecientes.reduce((a, b) => a + b, 0);\n    return Math.round(suma / flujosRecientes.length);\n}\n\n// Funci√≥n principal\nconst cola = msg.payload;\nlet flujo = 0;\nlet rellenando = flow.get(RELLENANDO_KEY) || false;\nlet flujosRecientes = flow.get(FLUJOS_RECIENTES_KEY) || [];\nlet colaVaciado = flow.get(COLA_VACIADO_KEY) || [];\n\nif (estaRellenando(cola)) {\n    if (!rellenando) {\n        rellenando = true;\n        flow.set(RELLENANDO_KEY, true);\n        node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando flujo promedio\"});\n    }\n    flujo = obtenerPromedioFlujo(flujosRecientes);\n    colaVaciado = []; // Reiniciar la cola de vaciado\n} else {\n    if (rellenando) {\n        // El rellenado acaba de terminar\n        rellenando = false;\n        flow.set(RELLENANDO_KEY, false);\n        colaVaciado = []; // Iniciar una nueva cola de vaciado\n        node.status({fill:\"green\", shape:\"dot\", text:\"Operaci√≥n normal - Iniciando nuevo vaciado\"});\n    }\n    \n    // A√±adir el nuevo registro a la cola de vaciado\n    colaVaciado.push(cola[cola.length - 1]);\n    \n    // Mantener solo los √∫ltimos 10 registros en la cola de vaciado\n    if (colaVaciado.length > 10) colaVaciado.shift();\n    \n    // Calcular el flujo usando la cola de vaciado\n    flujo = calcularFlujo(colaVaciado);\n    \n    // Actualizar flujos recientes solo si es una medici√≥n v√°lida\n    if (flujo > 0 && flujo <= 10000) {\n        flujosRecientes.push(flujo);\n        if (flujosRecientes.length > 10) flujosRecientes.shift();\n        flow.set(FLUJOS_RECIENTES_KEY, flujosRecientes);\n    }\n}\n\n// Guardar la cola de vaciado actualizada\nflow.set(COLA_VACIADO_KEY, colaVaciado);\n\nreturn { payload: flujo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 220,
        "wires": [
            [
                "dd8dae85c35d04e4"
            ]
        ]
    },
    {
        "id": "dd8dae85c35d04e4",
        "type": "ui-gauge",
        "z": "0a1446a2506c6a05",
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 940,
        "y": 220,
        "wires": []
    },
    {
        "id": "a04c9a1bff1e8e9c",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor num√©rico\nreturn msg;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 520,
        "wires": [
            [
                "e459b3f5a855d75d"
            ],
            []
        ]
    },
    {
        "id": "e459b3f5a855d75d",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no est√° disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 480,
        "wires": [
            [
                "f64f9862a7fe2280"
            ]
        ]
    },
    {
        "id": "f64f9862a7fe2280",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Flow Calculation Node",
        "func": "// Contexto del flujo para mantener el estado\nconst RELLENANDO_KEY = \"rellenando\";\nconst FLUJOS_RECIENTES_KEY = \"flujosRecientes\";\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    // Convertir los valores de volumen seg√∫n la escala proporcionada\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0) {\n        return Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nfunction estaRellenando(cola) {\n    if (cola.length < 2) return false;\n    const cambioVolumen = cola[cola.length - 1].volumen - cola[0].volumen;\n    return cambioVolumen > 150; // Considera rellenando si el volumen aumenta m√°s de 50 unidades\n}\n\nfunction obtenerPromedioFlujo(flujosRecientes) {\n    if (flujosRecientes.length === 0) return 0;\n    const suma = flujosRecientes.reduce((a, b) => a + b, 0);\n    return Math.round(suma / flujosRecientes.length);\n}\n\n// Funci√≥n principal\nconst cola = msg.payload;\nlet flujo = 0;\nlet rellenando = flow.get(RELLENANDO_KEY) || false;\nlet flujosRecientes = flow.get(FLUJOS_RECIENTES_KEY) || [];\n\nif (estaRellenando(cola)) {\n    if (!rellenando) {\n        // Acaba de comenzar el rellenado\n        rellenando = true;\n        flow.set(RELLENANDO_KEY, true);\n        node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando flujo promedio\"});\n    }\n    flujo = obtenerPromedioFlujo(flujosRecientes);\n} else {\n    if (rellenando) {\n        // El rellenado acaba de terminar\n        rellenando = false;\n        flow.set(RELLENANDO_KEY, false);\n        node.status({fill:\"green\", shape:\"dot\", text:\"Operaci√≥n normal\"});\n    }\n    flujo = calcularFlujo(cola);\n    \n    // Actualizar flujos recientes solo si es una medici√≥n v√°lida\n    if (flujo > 0 && flujo <= 10000) { // Asumiendo que el flujo m√°ximo es 10000 L/h\n        flujosRecientes.push(flujo);\n        // Mantener solo las √∫ltimas 10 mediciones v√°lidas\n        if (flujosRecientes.length > 10) flujosRecientes.shift();\n        flow.set(FLUJOS_RECIENTES_KEY, flujosRecientes);\n    }\n}\n\nreturn { payload: flujo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 420,
        "wires": [
            [
                "5be5b51bca193b4c"
            ]
        ]
    },
    {
        "id": "5be5b51bca193b4c",
        "type": "ui-gauge",
        "z": "0a1446a2506c6a05",
        "name": "Flujo Residuo",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo Residuo",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 970,
        "y": 420,
        "wires": []
    },
    {
        "id": "7a370c4b85b29ef1",
        "type": "change",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 520,
        "y": 380,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "b6d76655df7188ed",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic === \"\") || (msg.topic === null) || (msg.topic === undefined)) {\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Topic missing\" });\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current > 0) && (current % resendinterval === 0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg !== undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state === 1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\", []);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i = queue.length - 1; i >= 0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i, 1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\", queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length > 0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0, 1);\n        context.set(\"queue\", queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return [newmsg, null];\n        }\n    }\n}\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 600,
        "wires": [
            [
                "f8cd8be83e8d7779"
            ],
            [
                "6020fdaefe40e9e9",
                "dbe8eeeae1738d95"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "6020fdaefe40e9e9",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 640,
        "wires": [
            [
                "4437fa47ecc90bd8"
            ]
        ]
    },
    {
        "id": "d30a2726478f36f2",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 640,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "a581f35f17e7f31a",
        "type": "switch",
        "z": "663b1dbab4a22bc2",
        "name": "ADC2 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC2_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI4",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 900,
        "y": 540,
        "wires": [
            [
                "2c33bc86e7e229dd",
                "f8a3db9f9da14a3a"
            ],
            [
                "382644640ba019db"
            ],
            [
                "42d44f36569664ef"
            ],
            []
        ]
    },
    {
        "id": "6aa381426e6839ae",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 560,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "a09997d276d37f9b",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 600,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "382644640ba019db",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "calc_vol_FA-01",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (115500 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 420,
        "wires": [
            [
                "01c83f97683a617c",
                "a72c0d79c119556d",
                "0a4519ce7547ab03",
                "074fcbdf083ad42d",
                "cafbced0c971836b"
            ],
            []
        ]
    },
    {
        "id": "cfce2dc9702f3525",
        "type": "mqtt out",
        "z": "663b1dbab4a22bc2",
        "name": "mqtt_tb_MN-1",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "7ac8f4b3a29c864f",
        "x": 1500,
        "y": 440,
        "wires": []
    },
    {
        "id": "01c83f97683a617c",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 440,
        "wires": [
            [
                "cfce2dc9702f3525"
            ]
        ]
    },
    {
        "id": "a72c0d79c119556d",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 380,
        "wires": [
            [
                "3cc4a1f763f95c56"
            ]
        ]
    },
    {
        "id": "0a4519ce7547ab03",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "vol_FA-01",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1660,
        "y": 420,
        "wires": []
    },
    {
        "id": "f8a3db9f9da14a3a",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "calc_vol_FA-09",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (19000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 520,
        "wires": [
            [
                "67eff7b1d9e6b2ae",
                "8547335518cfc9b7",
                "8f578d08a192bb37",
                "c54458e807e51ddb"
            ],
            []
        ]
    },
    {
        "id": "5107b776e5769d96",
        "type": "mqtt out",
        "z": "663b1dbab4a22bc2",
        "name": "mqtt_tb_MN-9",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "bb61bb0c49cb82b4",
        "x": 1500,
        "y": 540,
        "wires": []
    },
    {
        "id": "67eff7b1d9e6b2ae",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 540,
        "wires": [
            [
                "5107b776e5769d96"
            ]
        ]
    },
    {
        "id": "8547335518cfc9b7",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 500,
        "wires": [
            [
                "e71d9fecf061811a"
            ]
        ]
    },
    {
        "id": "8f578d08a192bb37",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "vol_FA-09",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1660,
        "y": 520,
        "wires": []
    },
    {
        "id": "42d44f36569664ef",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "calc_vol_FA-07",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (200000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 640,
        "wires": [
            [
                "90fadc97f372d9f0",
                "dcaf92fde199c17f",
                "beffc6045a7dc2c2",
                "f677d22be9fdf34e"
            ],
            []
        ]
    },
    {
        "id": "e1c29a6e3db2cc13",
        "type": "mqtt out",
        "z": "663b1dbab4a22bc2",
        "name": "mqtt_tb_MN-7",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "aeb8c7546d28ce5c",
        "x": 1500,
        "y": 640,
        "wires": []
    },
    {
        "id": "90fadc97f372d9f0",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 640,
        "wires": [
            [
                "e1c29a6e3db2cc13"
            ]
        ]
    },
    {
        "id": "dcaf92fde199c17f",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 600,
        "wires": [
            [
                "1ddf871b6e31e48b"
            ]
        ]
    },
    {
        "id": "beffc6045a7dc2c2",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "vol_FA-07",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1680,
        "y": 620,
        "wires": []
    },
    {
        "id": "f8cd8be83e8d7779",
        "type": "modbus-flex-getter",
        "z": "663b1dbab4a22bc2",
        "name": "ADC2",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": false,
        "logIOActivities": false,
        "server": "661d09df777a5259",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 630,
        "y": 520,
        "wires": [
            [
                "7a370c4b85b29ef1",
                "a581f35f17e7f31a",
                "43a3a5014bf1b89c",
                "8661a36563068020"
            ],
            []
        ]
    },
    {
        "id": "3cc4a1f763f95c56",
        "type": "ui-chart",
        "z": "663b1dbab4a22bc2",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-01",
        "label": "Volumen FA-01",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "105000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1520,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "e71d9fecf061811a",
        "type": "ui-chart",
        "z": "663b1dbab4a22bc2",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-09",
        "label": "Volumen FA-09",
        "order": 3,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "20000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1520,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "1ddf871b6e31e48b",
        "type": "ui-chart",
        "z": "663b1dbab4a22bc2",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-07",
        "label": "Volumen FA-07",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "200000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1520,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "074fcbdf083ad42d",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-1', \n                equipo_id: 'FA-01', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 340,
        "wires": [
            [
                "e08c188598820f43"
            ]
        ]
    },
    {
        "id": "c54458e807e51ddb",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-9', \n                equipo_id: 'FA-09', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 480,
        "wires": [
            [
                "e08c188598820f43"
            ]
        ]
    },
    {
        "id": "f677d22be9fdf34e",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-7', \n                equipo_id: 'FA-07', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 580,
        "wires": [
            [
                "e08c188598820f43"
            ]
        ]
    },
    {
        "id": "cafbced0c971836b",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 42",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 300,
        "wires": []
    },
    {
        "id": "2c33bc86e7e229dd",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 43",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1020,
        "y": 360,
        "wires": []
    },
    {
        "id": "1f63aa4adb2f4e24",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 480,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "6cdd06e2ed6cd4f5",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 520,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "5b8a04908c59a547",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 220,
        "y": 440,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "e9367193c598413a",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 400,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "d3421cf0ddf70bf6",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 220,
        "wires": [
            [
                "0e493184c01a2490"
            ]
        ]
    },
    {
        "id": "7bdf0bcecb85ba5f",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 260,
        "wires": [
            [
                "657f3cbe468c3137"
            ]
        ]
    },
    {
        "id": "0e493184c01a2490",
        "type": "change",
        "z": "663b1dbab4a22bc2",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 370,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "657f3cbe468c3137",
        "type": "change",
        "z": "663b1dbab4a22bc2",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 390,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "f69cb68a7a2891f6",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "reset",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 360,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "dbe8eeeae1738d95",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "Status Queue",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 680,
        "wires": []
    },
    {
        "id": "4437fa47ecc90bd8",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 810,
        "y": 640,
        "wires": []
    },
    {
        "id": "e08c188598820f43",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "663b1dbab4a22bc2",
        "server": "a1b3d7fc83d5c6f6",
        "name": "DB",
        "x": 1910,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "43a3a5014bf1b89c",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 86",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 440,
        "wires": []
    },
    {
        "id": "3444a03605a05621",
        "type": "catch",
        "z": "663b1dbab4a22bc2",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 180,
        "y": 100,
        "wires": [
            [
                "b4624e19ee28a93a"
            ]
        ]
    },
    {
        "id": "b4624e19ee28a93a",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 92",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 100,
        "wires": []
    },
    {
        "id": "aadd6626fd1e9fbb",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "function 40",
        "func": "let topics = [\n    { topic: \"read_ADC2_AI1\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 0, \"quantity\": 1 } },\n    { topic: \"read_ADC2_AI2\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 1, \"quantity\": 1 } },\n    { topic: \"read_ADC2_AI3\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 2, \"quantity\": 1 } },\n    { topic: \"read_ADC2_AI4\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 3, \"quantity\": 1 } }\n];\n\nlet currentTopicIndex = context.get(\"currentTopicIndex\") || 0; // Track the current topic\nlet sendInterval = 2 * 1000; // 2-second interval for each topic (modifiable)\nlet currentTime = new Date().getTime();\nlet lastSentTime = context.get(\"lastSentTime\") || 0;\nlet queue = context.get(\"queue\") || [];\nlet state = context.get(\"state\") || 0;\nlet send = false;\nlet notifmsg = null; // Message for logging purposes\n\n// Retrieve the current topic and its associated payload\nlet currentTopic = topics[currentTopicIndex];\n\n// Calculate the time difference since the last message was sent\nlet timeDifference = currentTime - lastSentTime;\n\n// Check if it's time to send the next message for the current topic\nif (timeDifference >= sendInterval) {\n    // Add the current topic's Modbus read request to the queue\n    queue.push({ topic: currentTopic.topic, payload: currentTopic.payload });\n    context.set(\"queue\", queue);\n    context.set(\"lastSentTime\", currentTime);\n\n    // Prepare to send the message\n    send = true;\n\n    // Move to the next topic for the next cycle\n    currentTopicIndex = (currentTopicIndex + 1) % topics.length;\n    context.set(\"currentTopicIndex\", currentTopicIndex);\n\n    // Logging message preparation (2nd output)\n    notifmsg = { topic: \"Information\", payload: {} };\n    notifmsg.payload.updatetext = `Request sent for ${currentTopic.topic}`;\n\n    // Display the current status\n    node.status({ fill: \"green\", shape: \"dot\", text: `Request sent for ${currentTopic.topic}` });\n}\n\n// Check for device state and log warnings/errors if needed\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds above which the device is considered offline\n\nif (state !== 1) {\n    if (timeDifference < online_threshold) {\n        notifmsg = { topic: \"Warning\", payload: { text: \"Device is now online\", statuschange: true } };\n        state = 1; // Device is online\n        context.set(\"state\", state);\n    }\n} else {\n    if (timeDifference > offline_threshold) {\n        notifmsg = { topic: \"Error\", payload: { text: \"Device is not transmitting\", statuschange: true } };\n        state = 99; // Device is offline\n        context.set(\"state\", state);\n    }\n}\n\n// Send the Modbus request if ready\nif (send && queue.length > 0) {\n    let newMsg = queue.shift(); // Get the next message from the queue\n    context.set(\"queue\", queue);\n\n    // Return the Modbus request on the first output and logging on the second\n    return [newMsg, notifmsg];\n} else if (notifmsg) {\n    // In case there's no Modbus request but we still have a logging message\n    return [null, notifmsg];\n}\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 780,
        "wires": [
            [
                "f8cd8be83e8d7779"
            ],
            [
                "521ced58e89e6850"
            ]
        ]
    },
    {
        "id": "e9f422a45f69c88e",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 185,
        "y": 780,
        "wires": [
            [
                "aadd6626fd1e9fbb"
            ]
        ],
        "l": false
    },
    {
        "id": "521ced58e89e6850",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 860,
        "wires": [
            [
                "c5f92984658a6eac"
            ]
        ]
    },
    {
        "id": "c5f92984658a6eac",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 860,
        "wires": []
    },
    {
        "id": "9de9318f1d39ccc2",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 185,
        "y": 980,
        "wires": [
            [
                "c916098a878a089a"
            ]
        ],
        "l": false
    },
    {
        "id": "c916098a878a089a",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "function 41",
        "func": "let reconnectInterval = 60000; \nlet connectionState = context.get(\"connectionState\") || \"disconnected\"; // Initial state\nlet lastConnectionAttempt = context.get(\"lastConnectionAttempt\") || 0;\nlet currentTime = new Date().getTime();\n\nif (connectionState === \"disconnected\") {\n    if (currentTime - lastConnectionAttempt >= reconnectInterval) {\n        node.status({ fill: \"yellow\", shape: \"ring\", text: \"Reconnecting...\" });\n\n        let reconnectSuccess = reconnectModbusConnection(); // Implement this function\n        if (reconnectSuccess) {\n            connectionState = \"connected\";\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Connected\" });\n        } else {\n            node.warn(\"Reconnection attempt failed.\");\n        }\n\n        context.set(\"lastConnectionAttempt\", currentTime);\n    }\n} else if (connectionState === \"connected\") {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Connected\" });\n}\n\ncontext.set(\"connectionState\", connectionState);\nreturn msg;\n\nfunction reconnectModbusConnection() {\n    let reconnectMsg = {\n        topic: \"modbusReConnect\",\n        payload: {}\n    };\n    node.send([reconnectMsg]);  // Send reconnect message\n    return true;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 980,
        "wires": [
            [
                "bfd67dee9362a0c2"
            ]
        ]
    },
    {
        "id": "bfd67dee9362a0c2",
        "type": "link out",
        "z": "663b1dbab4a22bc2",
        "name": "link out 52",
        "mode": "link",
        "links": [
            "1ae9e1508ec9817c"
        ],
        "x": 475,
        "y": 980,
        "wires": []
    },
    {
        "id": "1ae9e1508ec9817c",
        "type": "link in",
        "z": "663b1dbab4a22bc2",
        "name": "link in 54",
        "links": [
            "bfd67dee9362a0c2"
        ],
        "x": 545,
        "y": 500,
        "wires": [
            [
                "f8cd8be83e8d7779"
            ]
        ]
    },
    {
        "id": "8661a36563068020",
        "type": "link out",
        "z": "663b1dbab4a22bc2",
        "name": "link out 53",
        "mode": "link",
        "links": [
            "af05fe1110900e68"
        ],
        "x": 705,
        "y": 560,
        "wires": []
    },
    {
        "id": "af05fe1110900e68",
        "type": "link in",
        "z": "663b1dbab4a22bc2",
        "name": "link in 55",
        "links": [
            "8661a36563068020"
        ],
        "x": 605,
        "y": 980,
        "wires": [
            [
                "9724f3e4f065af8e"
            ]
        ]
    },
    {
        "id": "9724f3e4f065af8e",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "function 42",
        "func": "if (msg.payload.error || msg.payload.errorCode === \"ECONNREFUSED\") {\n    // Connection lost\n    context.set(\"connectionState\", \"disconnected\");\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Connection lost\" });\n} else if (msg.payload.status === \"connected\") {\n    // Successfully connected\n    context.set(\"connectionState\", \"connected\");\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Connected\" });\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 980,
        "wires": [
            [
                "77d6f29326f43c8a"
            ]
        ]
    },
    {
        "id": "77d6f29326f43c8a",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 93",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 980,
        "wires": []
    },
    {
        "id": "984ab2045f44bcd5",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 600,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "7019d90458011b2a",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 760,
        "y": 560,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "aedffd40ec8c287c",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 980,
        "y": 680,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "011a5130f50f855b",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 800,
        "wires": [
            [
                "4fa27a733bf41ad4"
            ],
            [],
            [
                "4591bce234935eea"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "728fc737249824bf",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 520,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "a1c46aec8add99d8",
        "type": "link in",
        "z": "cf449ce1322fd8eb",
        "name": "link in 4",
        "links": [],
        "x": 795,
        "y": 480,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "4591bce234935eea",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "1c70cd3a4212709e",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 740,
        "y": 960,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "e1a822778a0fd165",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor num√©rico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1720,
        "y": 720,
        "wires": [
            [
                "840fc3448aa7be5e"
            ]
        ]
    },
    {
        "id": "c06d66220976b187",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no est√° disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1650,
        "y": 420,
        "wires": [
            [
                "ceea6d417693d667"
            ]
        ]
    },
    {
        "id": "ceea6d417693d667",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flow Calculation Node",
        "func": "const RELLENANDO_KEY = \"rellenando\";\nconst FLUJOS_RECIENTES_KEY = \"flujosRecientes\";\nconst COLA_VACIADO_VALIDA_KEY = \"colaVaciadoValida\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nfunction estaRellenando(ultimoVolumen, nuevoVolumen) {\n    return nuevoVolumen > ultimoVolumen + 150; // Considera rellenando si el volumen aumenta m√°s de 150 unidades\n}\n\nfunction obtenerPromedioFlujo(flujosRecientes) {\n    if (flujosRecientes.length === 0) return 0;\n    const suma = flujosRecientes.reduce((a, b) => a + b, 0);\n    return Math.round(suma / flujosRecientes.length);\n}\n\n// Funci√≥n principal\nconst ultimaLectura = msg.payload[msg.payload.length - 1];\nlet flujo = 0;\nlet rellenando = flow.get(RELLENANDO_KEY) || false;\nlet flujosRecientes = flow.get(FLUJOS_RECIENTES_KEY) || [];\nlet colaVaciadoValida = flow.get(COLA_VACIADO_VALIDA_KEY) || [];\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || 0;\n\nif (estaRellenando(ultimoVolumen, ultimaLectura.volumen)) {\n    if (!rellenando) {\n        rellenando = true;\n        flow.set(RELLENANDO_KEY, true);\n        node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando flujo promedio\"});\n    }\n    flujo = obtenerPromedioFlujo(flujosRecientes);\n    colaVaciadoValida = []; // Reiniciar la cola de vaciado v√°lida\n} else {\n    if (rellenando) {\n        // El rellenado acaba de terminar\n        rellenando = false;\n        flow.set(RELLENANDO_KEY, false);\n        colaVaciadoValida = []; // Iniciar una nueva cola de vaciado v√°lida\n        node.status({fill:\"green\", shape:\"dot\", text:\"Operaci√≥n normal - Iniciando nuevo vaciado\"});\n    }\n    \n    // A√±adir nuevo registro a la cola de vaciado v√°lida\n    if (colaVaciadoValida.length === 0 || ultimaLectura.volumen < colaVaciadoValida[colaVaciadoValida.length - 1].volumen) {\n        colaVaciadoValida.push(ultimaLectura);\n    }\n    \n    // Mantener solo los √∫ltimos 5 minutos de datos v√°lidos\n    const cincoMinutosAtras = Date.now() - 5 * 60 * 1000;\n    colaVaciadoValida = colaVaciadoValida.filter(registro => registro.tiempo >= cincoMinutosAtras);\n    \n    // Calcular el flujo usando solo los datos v√°lidos\n    flujo = calcularFlujo(colaVaciadoValida);\n    \n    // Si no se puede calcular un flujo v√°lido, usar el promedio de flujos recientes\n    if (flujo === 0 && flujosRecientes.length > 0) {\n        flujo = obtenerPromedioFlujo(flujosRecientes);\n    }\n    \n    // Actualizar flujos recientes solo si es una medici√≥n v√°lida\n    if (flujo > 0 && flujo <= 10000) {\n        flujosRecientes.push(flujo);\n        if (flujosRecientes.length > 10) flujosRecientes.shift();\n        flow.set(FLUJOS_RECIENTES_KEY, flujosRecientes);\n    }\n}\n\n// Guardar el √∫ltimo volumen para la pr√≥xima ejecuci√≥n\nflow.set(ULTIMO_VOLUMEN_KEY, ultimaLectura.volumen);\n\n// Guardar la cola de vaciado v√°lida actualizada\nflow.set(COLA_VACIADO_VALIDA_KEY, colaVaciadoValida);\n\nreturn { payload: flujo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 420,
        "wires": [
            [
                "8013d7446e6b7787",
                "739e2ec4f150a7c0",
                "0ca083d401370692"
            ]
        ]
    },
    {
        "id": "8013d7446e6b7787",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flujo COPE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2550,
        "y": 420,
        "wires": []
    },
    {
        "id": "4fa27a733bf41ad4",
        "type": "modbus-flex-getter",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1200,
        "y": 760,
        "wires": [
            [
                "aedffd40ec8c287c",
                "484a3352b3698f17"
            ],
            []
        ]
    },
    {
        "id": "484a3352b3698f17",
        "type": "switch",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI3",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1430,
        "y": 740,
        "wires": [
            [],
            [
                "73793c2aa437a1be"
            ],
            [],
            []
        ]
    },
    {
        "id": "739e2ec4f150a7c0",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "telemetria",
        "func": "msg.payload = {\n  flujo: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2200,
        "y": 420,
        "wires": [
            [
                "9d7ad836ba0bf6ed"
            ]
        ]
    },
    {
        "id": "9d7ad836ba0bf6ed",
        "type": "mqtt out",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "mqtt_flujocope",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f344d91a44765e3a",
        "x": 2380,
        "y": 420,
        "wires": []
    },
    {
        "id": "0ca083d401370692",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2090,
        "y": 300,
        "wires": []
    },
    {
        "id": "abed15d451c555f2",
        "type": "ui-chart",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02",
        "label": "Volumen FA-02",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisLabel": "",
        "xAxisProperty": "",
        "xAxisPropertyType": "property",
        "xAxisType": "category",
        "xAxisFormat": "",
        "xAxisFormatType": "auto",
        "yAxisLabel": "",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "stackSeries": true,
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": true,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "textColor": [
            "#666666"
        ],
        "textColorDefault": true,
        "gridColor": [
            "#e5e5e5"
        ],
        "gridColorDefault": true,
        "width": "2",
        "height": "4",
        "className": "",
        "x": 2200,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "840fc3448aa7be5e",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 720,
        "wires": [
            [
                "abed15d451c555f2"
            ]
        ]
    },
    {
        "id": "cee38009337acfd3",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 360,
        "wires": [
            [
                "5b527a16a2653a03"
            ]
        ]
    },
    {
        "id": "7fe9d1241bda08c0",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 400,
        "wires": [
            [
                "3fdc5a44ea1c053c"
            ]
        ]
    },
    {
        "id": "5b527a16a2653a03",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1010,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "3fdc5a44ea1c053c",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1030,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "d40096130b974dce",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 680,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "1647bc6e4b31b983",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "cec4be2929b61562",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "5bae632b1f69002c",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "d2b8a91aee81bbd2",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 840,
        "wires": [
            []
        ]
    },
    {
        "id": "2ae0af8f7862a3f3",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI5",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI5",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":6,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "e5c207b65b6d9a0a",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "State Detection",
        "func": "// Obtener las √∫ltimas lecturas de volumen del contexto\nlet lecturasVolumen = flow.get(\"lecturasVolumen\") || [];\n\n// A√±adir la nueva lectura\nlecturasVolumen.push(msg.payload.volumen);\n\n// Mantener solo las √∫ltimas 10 lecturas\nif (lecturasVolumen.length > 10) {\n    lecturasVolumen.shift();\n}\n\n// Guardar las lecturas actualizadas en el contexto\nflow.set(\"lecturasVolumen\", lecturasVolumen);\n\n// Inicializar contadores\nlet aumentos = 0;\nlet disminuciones = 0;\nlet estables = 0;\n\n// Analizar las lecturas para detectar el estado\nfor (let i = 1; i < lecturasVolumen.length; i++) {\n    let diferencia = lecturasVolumen[i] - lecturasVolumen[i - 1];\n    if (diferencia > 0) {\n        aumentos++;\n        disminuciones = 0;\n        estables = 0;\n    } else if (diferencia < 0) {\n        disminuciones++;\n        aumentos = 0;\n        estables = 0;\n    } else {\n        estables++;\n        aumentos = 0;\n        disminuciones = 0;\n    }\n}\n\n// Determinar el estado\nlet estado = flow.get(\"estado\") || \"Desconocido\";\n\nif (aumentos >= 4) {\n    estado = \"Relleno\";\n} else if (disminuciones >= 4) {\n    estado = \"Alimentaci√≥n\";\n} else if (estables >= 10 && Math.abs(lecturasVolumen[lecturasVolumen.length - 1] - lecturasVolumen[lecturasVolumen.length - 2]) <= 20) {\n    estado = \"Estable\";\n}\n\n// Guardar el estado en el contexto\nflow.set(\"estado\", estado);\n\n// A√±adir el estado al mensaje\nmsg.estado = estado;\n\n// Pasar el mensaje al siguiente nodo\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1860,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "2ef0ebdea5ea4864",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Flow Calculation Node",
        "func": "const cola = msg.payload;\nlet flujo = 0;\n\nif (cola.length > 1) {\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    // Convertir los valores de volumen seg√∫n la escala proporcionada\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0) {\n        flujo = Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600); // calcular flujo\n    }\n} else {\n    // Manejar el caso cuando no hay suficientes registros para calcular un flujo\n    flujo = \"Insuficientes datos para c√°lculo de flujo\";\n}\n\n// Devolver el valor del flujo\nreturn { payload: flujo };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "08481f95f5e7ae86",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no est√° disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 120,
        "wires": [
            [
                "2ef0ebdea5ea4864"
            ]
        ]
    },
    {
        "id": "f072d5245b0083c4",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Flow Calculation Node",
        "func": "const cola = msg.payload;\nlet flujo = 0;\n\nif (cola.length > 1) {\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    // Convertir los valores de volumen seg√∫n la escala proporcionada\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0) {\n        flujo = Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600); // calcular flujo\n    }\n} else {\n    // Manejar el caso cuando no hay suficientes registros para calcular un flujo\n    flujo = \"Insuficientes datos para c√°lculo de flujo\";\n}\n\n// Devolver el valor del flujo\nreturn { payload: flujo };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1760,
        "y": 1060,
        "wires": [
            []
        ]
    },
    {
        "id": "8bfb32aad261daeb",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual\nconst tiempoRegistro = Date.now();\ncola.push({\n    tiempo: tiempoRegistro,\n    valor: msg.payload // Usar msg.payload directamente\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1750,
        "y": 1120,
        "wires": [
            [
                "f072d5245b0083c4",
                "34f58050e2572dc8"
            ]
        ]
    },
    {
        "id": "73793c2aa437a1be",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "CalculoFlujo",
        "func": "// Claves para almacenar en el contexto del flujo\nconst COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\n// Funci√≥n para detectar el estado del tanque\nfunction detectarEstado(lecturas) {\n    if (lecturas.length < 4) return \"desconocido\";\n    \n    let aumentos = 0;\n    let disminuciones = 0;\n    let estables = 0;\n    \n    for (let i = lecturas.length - 4; i < lecturas.length - 1; i++) {\n        let diferencia = lecturas[i + 1].volumen - lecturas[i].volumen;\n        if (diferencia > 0) {\n            aumentos++;\n        } else if (diferencia < 0) {\n            disminuciones++;\n        } else if (Math.abs(diferencia) <= 20) {\n            estables++;\n        }\n    }\n    \n    if (aumentos >= 4) {\n        return \"rellenando\";\n    } else if (disminuciones >= 4) {\n        return \"alimentando\";\n    } else if (estables >= 10) {\n        return \"estable\";\n    } else {\n        return \"desconocido\";\n    }\n}\n\n// Funci√≥n para calcular el flujo\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    // Convertir los valores de volumen seg√∫n la escala proporcionada\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * 40000;\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * 40000;\n\n    if (tiempoDiferencia > 0) {\n        let flujoCalculado = Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600); // calcular flujo en L/h\n        return flujoCalculado;\n    } else {\n        return 0;\n    }\n}\n\n// Obtener la cola de lecturas y otros valores del contexto\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"desconocido\";\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\n// A√±adir la nueva lectura\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload // Asumiendo que el volumen viene en msg.payload\n};\n\ncolaLecturas.push(nuevaLectura);\n\n// Mantener solo las √∫ltimas 15 lecturas\nif (colaLecturas.length > 15) colaLecturas.shift();\n\n// Detectar el estado actual del tanque\nconst nuevoEstado = detectarEstado(colaLecturas);\n\n// Manejar cambios de estado\nif (nuevoEstado !== estadoTanque) {\n    if (nuevoEstado === \"rellenando\") {\n        // Calcular el valor fijo usando las lecturas antes del inicio del relleno\n        // Excluimos las √∫ltimas 4 lecturas que indican el inicio del relleno\n        const lecturasAntesRelleno = colaLecturas.slice(0, -4);\n        if (lecturasAntesRelleno.length >= 2) {\n            valorFijo = calcularFlujo(lecturasAntesRelleno);\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        } else {\n            valorFijo = 0; // Si no hay suficientes lecturas, establecemos 0\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        }\n    } else if (nuevoEstado === \"alimentando\") {\n        valorFijo = 0; // Resetear el valor fijo al comenzar la alimentaci√≥n\n        flow.set(VALOR_FIJO_KEY, valorFijo);\n    }\n    estadoTanque = nuevoEstado;\n    flow.set(ESTADO_TANQUE_KEY, estadoTanque);\n}\n\n// Calcular el flujo seg√∫n el estado actual\nlet flujoCalculado;\nif (estadoTanque === \"rellenando\") {\n    flujoCalculado = valorFijo;\n    node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando valor fijo\"});\n} else if (estadoTanque === \"alimentando\") {\n    flujoCalculado = calcularFlujo(colaLecturas);\n    node.status({fill:\"green\", shape:\"dot\", text:\"Alimentando - Flujo calculado\"});\n} else if (estadoTanque === \"estable\") {\n    flujoCalculado = 0;\n    node.status({fill:\"blue\", shape:\"ring\", text:\"Estable - Flujo cero\"});\n} else {\n    flujoCalculado = 0;\n    node.status({fill:\"grey\", shape:\"ring\", text:\"Estado desconocido\"});\n}\n\n// Guardar la cola de lecturas actualizada en el contexto\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\n\n// Devolver el flujo calculado\nreturn { payload: flujoCalculado, estado: estadoTanque };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1610,
        "y": 360,
        "wires": [
            [
                "e3b3819b25087cd6"
            ]
        ]
    },
    {
        "id": "e3b3819b25087cd6",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 1810,
        "y": 360,
        "wires": []
    },
    {
        "id": "1c37b9c4281deee6",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flow Calculation Node",
        "func": "// Claves para almacenar en el contexto del flujo\nconst COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\n// Funci√≥n para detectar el estado del tanque\nfunction detectarEstado(lecturas) {\n    if (lecturas.length < 4) return \"desconocido\";\n    \n    let aumentos = 0;\n    let disminuciones = 0;\n    let estables = 0;\n    \n    for (let i = lecturas.length - 4; i < lecturas.length - 1; i++) {\n        let diferencia = lecturas[i + 1].volumen - lecturas[i].volumen;\n        if (diferencia > 0) {\n            aumentos++;\n        } else if (diferencia < 0) {\n            disminuciones++;\n        } else if (Math.abs(diferencia) <= 20) {\n            estables++;\n        }\n    }\n    \n    if (aumentos >= 4) {\n        return \"rellenando\";\n    } else if (disminuciones >= 4) {\n        return \"alimentando\";\n    } else if (estables >= 10) {\n        return \"estable\";\n    } else {\n        return \"desconocido\";\n    }\n}\n\n// Funci√≥n para calcular el flujo\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    // Convertir los valores de volumen seg√∫n la escala proporcionada\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * 40000;\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * 40000;\n\n    if (tiempoDiferencia > 0) {\n        let flujoCalculado = Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600); // calcular flujo en L/h\n        return flujoCalculado;\n    } else {\n        return 0;\n    }\n}\n\n// Obtener la cola de lecturas y otros valores del contexto\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"desconocido\";\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\n// A√±adir la nueva lectura\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload // Asumiendo que el volumen viene en msg.payload\n};\n\ncolaLecturas.push(nuevaLectura);\n\n// Mantener solo las √∫ltimas 15 lecturas\nif (colaLecturas.length > 15) colaLecturas.shift();\n\n// Detectar el estado actual del tanque\nconst nuevoEstado = detectarEstado(colaLecturas);\n\n// Manejar cambios de estado\nif (nuevoEstado !== estadoTanque) {\n    if (nuevoEstado === \"rellenando\") {\n        // Calcular el valor fijo usando las lecturas antes del inicio del relleno\n        // Excluimos las √∫ltimas 4 lecturas que indican el inicio del relleno\n        const lecturasAntesRelleno = colaLecturas.slice(0, -4);\n        if (lecturasAntesRelleno.length >= 2) {\n            valorFijo = calcularFlujo(lecturasAntesRelleno);\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        } else {\n            valorFijo = 0; // Si no hay suficientes lecturas, establecemos 0\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        }\n    } else if (nuevoEstado === \"alimentando\") {\n        valorFijo = 0; // Resetear el valor fijo al comenzar la alimentaci√≥n\n        flow.set(VALOR_FIJO_KEY, valorFijo);\n    }\n    estadoTanque = nuevoEstado;\n    flow.set(ESTADO_TANQUE_KEY, estadoTanque);\n}\n\n// Calcular el flujo seg√∫n el estado actual\nlet flujoCalculado;\nif (estadoTanque === \"rellenando\") {\n    flujoCalculado = valorFijo;\n    node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando valor fijo\"});\n} else if (estadoTanque === \"alimentando\") {\n    flujoCalculado = calcularFlujo(colaLecturas);\n    node.status({fill:\"green\", shape:\"dot\", text:\"Alimentando - Flujo calculado\"});\n} else if (estadoTanque === \"estable\") {\n    flujoCalculado = 0;\n    node.status({fill:\"blue\", shape:\"ring\", text:\"Estable - Flujo cero\"});\n} else {\n    flujoCalculado = 0;\n    node.status({fill:\"grey\", shape:\"ring\", text:\"Estado desconocido\"});\n}\n\n// Guardar la cola de lecturas actualizada en el contexto\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\n\n// Asegurarse de que flujoCalculado sea un n√∫mero\nflujoCalculado = Number(flujoCalculado) || 0;\n\n// Log para depuraci√≥n\nconsole.log(\"Flujo calculado:\", flujoCalculado, \"Estado:\", estadoTanque);\n\n// Devolver solo el valor num√©rico en el payload\nreturn { payload: flujoCalculado };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2060,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "inject-node",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "Iniciar",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 890,
        "y": 1100,
        "wires": [
            [
                "function-node"
            ]
        ]
    },
    {
        "id": "function-node",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Decrementar",
        "func": "let value = context.get('value');\n\nif (value === undefined || value < 0) {\n    value = 20000;\n}\n\nmsg.payload = value;\nvalue--;\ncontext.set('value', value);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1100,
        "wires": [
            [
                "delay-node",
                "debug-node",
                "6a099551450d6cf2",
                "6912ce81cf94a075",
                "e1a822778a0fd165",
                "8bfb32aad261daeb"
            ]
        ]
    },
    {
        "id": "delay-node",
        "type": "delay",
        "z": "cf449ce1322fd8eb",
        "name": "Retardo 1 segundo",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1250,
        "y": 1100,
        "wires": [
            [
                "function-node"
            ]
        ]
    },
    {
        "id": "debug-node",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver en consola",
        "active": true,
        "tosidebar": true,
        "console": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 1260,
        "y": 1160,
        "wires": []
    },
    {
        "id": "6912ce81cf94a075",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no est√° disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload // Usar directamente msg.payload\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 1710,
        "y": 840,
        "wires": [
            [
                "aec536a7489b60be"
            ]
        ]
    },
    {
        "id": "aec536a7489b60be",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flow Calculation Node",
        "func": "// Claves para almacenar en el contexto del flujo\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\n// Obtener la cola de lecturas desde msg.payload\nlet colaLecturas = msg.payload;\n\n// Obtener el estado anterior y el valor fijo desde el contexto\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"desconocido\";\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\n// Funci√≥n para detectar el estado del tanque\nfunction detectarEstado(lecturas) {\n    if (lecturas.length < 4) return \"desconocido\";\n\n    let disminuciones = 0;\n    let aumentos = 0;\n    let estables = 0;\n\n    for (let i = lecturas.length - 4; i < lecturas.length - 1; i++) {\n        let diferencia = lecturas[i + 1].volumen - lecturas[i].volumen;\n        if (diferencia < -0.5) {\n            disminuciones++;\n        } else if (diferencia > 0.5) {\n            aumentos++;\n        } else {\n            estables++;\n        }\n    }\n\n    if (disminuciones >= 3) return \"alimentando\";\n    if (aumentos >= 3) return \"rellenando\";\n    if (estables >= 3) return \"estable\";\n    return \"desconocido\";\n}\n\n// Funci√≥n para calcular el flujo\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    if (tiempoDiferencia > 0) {\n        const volumenInicial = primerRegistro.volumen;\n        const volumenFinal = ultimoRegistro.volumen;\n        const diferenciaVolumen = volumenInicial - volumenFinal;\n        \n        // Convertir la diferencia de volumen a la escala de 0-40000\n        const diferenciaEscalada = (diferenciaVolumen / (20000 - 4000)) * 40000;\n        \n        // Calcular el flujo en L/h, siempre positivo\n        let flujoCalculado = Math.abs(Math.round((diferenciaEscalada / tiempoDiferencia) * 3600));\n        return flujoCalculado;\n    } else {\n        return 0;\n    }\n}\n\n// Detectar el estado actual del tanque\nconst nuevoEstado = detectarEstado(colaLecturas);\n\n// Manejar cambios de estado\nif (nuevoEstado !== estadoTanque) {\n    if (nuevoEstado === \"rellenando\") {\n        const lecturasAntesRelleno = colaLecturas.slice(0, -4);\n        if (lecturasAntesRelleno.length >= 2) {\n            valorFijo = calcularFlujo(lecturasAntesRelleno);\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        } else {\n            valorFijo = 0;\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        }\n    } else if (nuevoEstado === \"alimentando\") {\n        valorFijo = 0;\n        flow.set(VALOR_FIJO_KEY, valorFijo);\n    }\n    estadoTanque = nuevoEstado;\n    flow.set(ESTADO_TANQUE_KEY, estadoTanque);\n}\n\n// Calcular el flujo seg√∫n el estado actual\nlet flujoCalculado;\nif (estadoTanque === \"rellenando\") {\n    flujoCalculado = valorFijo;\n    node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando valor fijo\"});\n} else if (estadoTanque === \"alimentando\") {\n    flujoCalculado = calcularFlujo(colaLecturas);\n    node.status({fill:\"green\", shape:\"dot\", text:\"Alimentando - Flujo calculado\"});\n} else if (estadoTanque === \"estable\") {\n    flujoCalculado = 0;\n    node.status({fill:\"blue\", shape:\"ring\", text:\"Estable - Flujo cero\"});\n} else {\n    flujoCalculado = 0;\n    node.status({fill:\"grey\", shape:\"ring\", text:\"Estado desconocido\"});\n}\n\n// Asegurarse de que flujoCalculado sea un n√∫mero positivo\nflujoCalculado = Math.abs(Number(flujoCalculado)) || 0;\n\n// Log para depuraci√≥n\nconsole.log(\"Estado:\", estadoTanque, \"Flujo calculado:\", flujoCalculado);\n\n// Devolver el flujo calculado y el estado\nreturn [{ payload: flujoCalculado }, { payload: estadoTanque }];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1950,
        "y": 840,
        "wires": [
            [
                "08c3459fd6a3321e",
                "bd046d660e3fb82f",
                "e4ab6edbc55afaf3"
            ],
            [
                "87a4cd70ddf38bd4"
            ]
        ]
    },
    {
        "id": "08c3459fd6a3321e",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Debug Flujo",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 2180,
        "y": 840,
        "wires": []
    },
    {
        "id": "87a4cd70ddf38bd4",
        "type": "ui-text",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "group": "3f690bb5a526a246",
        "order": 5,
        "width": "5",
        "height": "1",
        "name": "Estado del Tanque",
        "label": "Estado:",
        "format": "{{msg.payload}}",
        "layout": "row-spread",
        "className": "",
        "x": 2180,
        "y": 880,
        "wires": []
    },
    {
        "id": "bd046d660e3fb82f",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Debug Estado",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "estadoTanque",
        "targetType": "flow",
        "x": 2190,
        "y": 760,
        "wires": []
    },
    {
        "id": "e4ab6edbc55afaf3",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2190,
        "y": 800,
        "wires": []
    },
    {
        "id": "b6ece23c7664678a",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Incrementar",
        "func": "let value = context.get('value') || 4000;\n\nif (value <= 20000) {\n    node.send({ payload: value });\n    value++; \n    context.set('value', value);\n} else {\n    context.set('value', 4000);\n}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 1220,
        "wires": [
            [
                "40e565bc204794ba",
                "3cc5a6c004a089cd",
                "6a099551450d6cf2",
                "6912ce81cf94a075",
                "e1a822778a0fd165"
            ]
        ]
    },
    {
        "id": "40e565bc204794ba",
        "type": "delay",
        "z": "cf449ce1322fd8eb",
        "name": "Retardo 1 segundo",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "2",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1250,
        "y": 1220,
        "wires": [
            [
                "b6ece23c7664678a"
            ]
        ]
    },
    {
        "id": "ecd5b6d0ef39cc32",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "Iniciar",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 890,
        "y": 1220,
        "wires": [
            [
                "b6ece23c7664678a"
            ]
        ]
    },
    {
        "id": "3cc5a6c004a089cd",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver en consola",
        "active": true,
        "tosidebar": true,
        "console": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 1260,
        "y": 1280,
        "wires": []
    },
    {
        "id": "function-node-stable",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Simular Estado Estable",
        "func": "let value = context.get('value') || 5000;\n\n// Generar un n√∫mero aleatorio entre -5 y 5\nlet fluctuation = Math.floor(Math.random() * 11) - 5;\n\n// Aplicar la fluctuaci√≥n al valor\nvalue += fluctuation;\n\n// Asegurar que el valor se mantenga en el rango de 4995 a 5005\nvalue = Math.max(4995, Math.min(5005, value));\n\n// Enviar el valor y guardarlo en el contexto\nnode.send({ payload: value });\ncontext.set('value', value);\n\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 1400,
        "wires": [
            [
                "6c36579780f7f021",
                "4f07c629f0ae2bd9",
                "6912ce81cf94a075",
                "e1a822778a0fd165",
                "6a099551450d6cf2"
            ]
        ]
    },
    {
        "id": "62d65a19d570dd02",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "Iniciar",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 850,
        "y": 1400,
        "wires": [
            [
                "function-node-stable"
            ]
        ]
    },
    {
        "id": "6c36579780f7f021",
        "type": "delay",
        "z": "cf449ce1322fd8eb",
        "name": "Retardo 1 segundo",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "outputs": 1,
        "x": 1250,
        "y": 1400,
        "wires": [
            [
                "function-node-stable"
            ]
        ]
    },
    {
        "id": "4f07c629f0ae2bd9",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver en consola",
        "active": true,
        "tosidebar": true,
        "console": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 1260,
        "y": 1460,
        "wires": []
    },
    {
        "id": "6a099551450d6cf2",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no est√° disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload // Usar directamente msg.payload\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 1450,
        "y": 1620,
        "wires": [
            [
                "9af74103a3a25351"
            ]
        ]
    },
    {
        "id": "9af74103a3a25351",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flow Calculation Node",
        "func": "// Claves para almacenar en el contexto del flujo\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\n// Obtener la cola de lecturas desde msg.payload\nlet colaLecturas = msg.payload;\n\n// Obtener el estado anterior y el valor fijo desde el contexto\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"desconocido\";\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\n// Funci√≥n para detectar el estado del tanque\nfunction detectarEstado(lecturas) {\n    if (lecturas.length < 4) return \"desconocido\";\n\n    let disminuciones = 0;\n    let aumentos = 0;\n    let estables = 0;\n\n    for (let i = lecturas.length - 4; i < lecturas.length - 1; i++) {\n        let diferencia = lecturas[i + 1].volumen - lecturas[i].volumen;\n        if (diferencia < -0.5) {\n            disminuciones++;\n        } else if (diferencia > 0.5) {\n            aumentos++;\n        } else {\n            estables++;\n        }\n    }\n\n    if (disminuciones >= 3) return \"alimentando\";\n    if (aumentos >= 3) return \"rellenando\";\n    if (estables >= 3) return \"estable\";\n    return \"desconocido\";\n}\n\n// Funci√≥n para calcular el flujo (sin cambios)\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    if (tiempoDiferencia > 0) {\n        const volumenInicial = primerRegistro.volumen;\n        const volumenFinal = ultimoRegistro.volumen;\n        const diferenciaVolumen = volumenInicial - volumenFinal;\n        \n        // Convertir la diferencia de volumen a la escala de 0-40000\n        const diferenciaEscalada = (diferenciaVolumen / (20000 - 4000)) * 40000;\n        \n        // Calcular el flujo en L/h, siempre positivo\n        let flujoCalculado = Math.abs(Math.round((diferenciaEscalada / tiempoDiferencia) * 3600));\n        return flujoCalculado;\n    } else {\n        return 0;\n    }\n}\n\n// Detectar el estado actual del tanque\nconst nuevoEstado = detectarEstado(colaLecturas);\n\n// Manejar cambios de estado\nif (nuevoEstado !== estadoTanque) {\n    if (nuevoEstado === \"rellenando\") {\n        const lecturasAntesRelleno = colaLecturas.slice(0, -4);\n        if (lecturasAntesRelleno.length >= 2) {\n            valorFijo = calcularFlujo(lecturasAntesRelleno);\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        } else {\n            valorFijo = 0;\n            flow.set(VALOR_FIJO_KEY, valorFijo);\n        }\n    } else if (nuevoEstado === \"alimentando\") {\n        valorFijo = 0;\n        flow.set(VALOR_FIJO_KEY, valorFijo);\n    }\n    estadoTanque = nuevoEstado;\n    flow.set(ESTADO_TANQUE_KEY, estadoTanque);\n}\n\n// Calcular el flujo seg√∫n el estado actual\nlet flujoCalculado;\nif (estadoTanque === \"rellenando\") {\n    flujoCalculado = valorFijo;\n    node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando valor fijo\"});\n} else if (estadoTanque === \"alimentando\") {\n    flujoCalculado = calcularFlujo(colaLecturas);\n    node.status({fill:\"green\", shape:\"dot\", text:\"Alimentando - Flujo calculado\"});\n} else if (estadoTanque === \"estable\") {\n    flujoCalculado = 0;  // Flujo cero en estado estable\n    node.status({fill:\"blue\", shape:\"ring\", text:\"Estable - Flujo cero\"});\n} else {\n    flujoCalculado = 0;  // Flujo cero en estado desconocido\n    node.status({fill:\"grey\", shape:\"ring\", text:\"Estado desconocido - Flujo cero\"});\n}\n\n// Log para depuraci√≥n\nconsole.log(\"Estado:\", estadoTanque, \"Flujo calculado:\", flujoCalculado);\n\n// Devolver el flujo calculado y el estado\nreturn [{ payload: flujoCalculado }, { payload: estadoTanque }];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 1620,
        "wires": [
            [
                "c6238902c4c4e08e",
                "a7939e1ed6d563bd",
                "7f97a33f373e36b9"
            ],
            [
                "a3e3b188f84cb22e"
            ]
        ]
    },
    {
        "id": "c6238902c4c4e08e",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Debug Flujo",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 1920,
        "y": 1620,
        "wires": []
    },
    {
        "id": "a3e3b188f84cb22e",
        "type": "ui-text",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "group": "3f690bb5a526a246",
        "order": 5,
        "width": "5",
        "height": "1",
        "name": "Estado del Tanque",
        "label": "Estado:",
        "format": "{{msg.payload}}",
        "layout": "row-spread",
        "className": "",
        "x": 1920,
        "y": 1660,
        "wires": []
    },
    {
        "id": "a7939e1ed6d563bd",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Debug Estado",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "estadoTanque",
        "targetType": "flow",
        "x": 1930,
        "y": 1540,
        "wires": []
    },
    {
        "id": "7f97a33f373e36b9",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 1930,
        "y": 1580,
        "wires": []
    },
    {
        "id": "34f58050e2572dc8",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "function 43",
        "func": "// Suponiendo que msg.payload es la cola de valores\nlet cola = msg.payload;\n\n// Verificar que haya suficientes datos para comparar\nif (cola.length >= 2) {\n    // Obtener los valores necesarios\n    const valorAnterior = cola[cola.length - 2].valor;\n    const valorActual = cola[cola.length - 1].valor;\n\n    // Comparar los valores para determinar la tendencia\n    if (valorActual > valorAnterior) {\n        msg.payload = 'aumentando';\n    } else if (valorActual < valorAnterior) {\n        msg.payload = 'disminuyendo';\n    } else {\n        msg.payload = 'sin cambio';\n    }\n} else {\n    // Si no hay suficientes datos, informar\n    msg.payload = 'Datos insuficientes para determinar la tendencia';\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1990,
        "y": 1060,
        "wires": [
            []
        ]
    },
    {
        "id": "0568bbba8b436882",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Decrementar",
        "func": "let value = context.get('value');\n\nif (value === undefined || value <= 0) {\n    value = 20000;\n}\n\nmsg.payload = value;\nvalue--;\ncontext.set('value', value);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "x": 2650,
        "y": 2180,
        "wires": [
            [
                "87f4069ec6b3f504",
                "cd9fb8a2e7d6a362",
                "316efee7c7e1cbce"
            ]
        ]
    },
    {
        "id": "cd9fb8a2e7d6a362",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver Decrementar",
        "active": true,
        "tosidebar": true,
        "console": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 2890,
        "y": 2240,
        "wires": []
    },
    {
        "id": "87f4069ec6b3f504",
        "type": "delay",
        "z": "cf449ce1322fd8eb",
        "name": "Retardo 2 segundos",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "",
        "randomLast": "",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2850,
        "y": 2180,
        "wires": [
            [
                "0568bbba8b436882"
            ]
        ]
    },
    {
        "id": "142087131ac48d94",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "Iniciar",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 2470,
        "y": 2180,
        "wires": [
            [
                "0568bbba8b436882"
            ]
        ]
    },
    {
        "id": "b4c67729d907f710",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Data Accumulation Node",
        "func": "let lecturas = flow.get(\"lecturasVolumen\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual\nconst registro = {\n    tiempo: Date.now(),\n    volumen: msg.payload // Usar msg.payload directamente\n};\nlecturas.push(registro);\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nconst tiempoActual = Date.now();\nlecturas = lecturas.filter(r => (tiempoActual - r.tiempo) <= tiempoMaximo);\n\n// Guardar las lecturas actualizadas en el contexto del flujo\nflow.set(\"lecturasVolumen\", lecturas);\n\n// Pasar las lecturas completas al siguiente nodo para su procesamiento\nreturn { payload: lecturas };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2520,
        "y": 2320,
        "wires": [
            [
                "a2cecd8688116999",
                "50f05e58605974bb"
            ]
        ]
    },
    {
        "id": "a2cecd8688116999",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Detectar Rellenado",
        "func": "const lecturas = msg.payload;\nconst estadoAnterior = flow.get('estadoRellenado') || 'Operaci√≥n Normal';\nlet estadoActual = estadoAnterior;\n\nconst umbralIncremento = 3; // Ajustar seg√∫n el incremento que indique rellenado\nconst umbralLecturas = 5; // N√∫mero de lecturas para considerar el incremento\n\nif (lecturas.length >= umbralLecturas) {\n    const volumenAnterior = lecturas[lecturas.length - umbralLecturas].volumen;\n    const volumenActual = lecturas[lecturas.length - 1].volumen;\n    const deltaVolumen = volumenActual - volumenAnterior;\n\n    if (deltaVolumen >= umbralIncremento && estadoAnterior === 'Operaci√≥n Normal') {\n        estadoActual = 'En Rellenado';\n        flow.set('inicioRellenado', Date.now());\n    } else if (deltaVolumen <= 0 && estadoAnterior === 'En Rellenado') {\n        estadoActual = 'Operaci√≥n Normal';\n        flow.set('finRellenado', Date.now());\n    }\n}\n\nflow.set('estadoRellenado', estadoActual);\nmsg.payload = estadoActual;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2750,
        "y": 2320,
        "wires": [
            [
                "50f05e58605974bb"
            ]
        ]
    },
    {
        "id": "50f05e58605974bb",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Calcular Flujo",
        "func": "const lecturas = flow.get(\"lecturasVolumen\");\nconst estadoRellenado = flow.get('estadoRellenado') || 'Operaci√≥n Normal';\nlet flujo = null;\n\nif (estadoRellenado === 'Operaci√≥n Normal') {\n    if (lecturas.length >= 2) {\n        const volumenAnterior = lecturas[lecturas.length - 2].volumen;\n        const tiempoAnterior = lecturas[lecturas.length - 2].tiempo;\n        const volumenActual = lecturas[lecturas.length - 1].volumen;\n        const tiempoActual = lecturas[lecturas.length - 1].tiempo;\n\n        const deltaVolumen = volumenActual - volumenAnterior;\n        const deltaTiempo = (tiempoActual - tiempoAnterior) / 1000; // en segundos\n\n        flujo = -deltaVolumen / deltaTiempo; // Negativo porque el volumen disminuye\n\n        // Guardar el √∫ltimo flujo v√°lido\n        flow.set('ultimoFlujoValido', flujo);\n    } else {\n        flujo = flow.get('ultimoFlujoValido') || 0;\n    }\n} else if (estadoRellenado === 'En Rellenado') {\n    // Usar el √∫ltimo flujo v√°lido\n    flujo = flow.get('ultimoFlujoValido') || 0;\n}\n\nmsg.payload = {\n    flujo: flujo,\n    estado: estadoRellenado\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2960,
        "y": 2320,
        "wires": [
            [
                "e0e6929eae6eb323",
                "d18de17a173e405b"
            ]
        ]
    },
    {
        "id": "e0e6929eae6eb323",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver Flujo",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.flujo",
        "targetType": "msg",
        "x": 3120,
        "y": 2280,
        "wires": []
    },
    {
        "id": "d18de17a173e405b",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver Estado",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.estado",
        "targetType": "msg",
        "x": 3120,
        "y": 2320,
        "wires": []
    },
    {
        "id": "1e7408a44bb6c103",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Incrementar",
        "func": "let value = context.get('value') || 4000;\n\nif (value <= 20000) {\n    node.send({ payload: value });\n    value++; \n    context.set('value', value);\n} else {\n    context.set('value', 4000);\n}\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2090,
        "y": 2200,
        "wires": [
            [
                "395f4213228f79e0",
                "1f113caa7dcee4f9",
                "316efee7c7e1cbce"
            ]
        ]
    },
    {
        "id": "395f4213228f79e0",
        "type": "delay",
        "z": "cf449ce1322fd8eb",
        "name": "Retardo 1 segundo",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "2",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2290,
        "y": 2200,
        "wires": [
            [
                "1e7408a44bb6c103"
            ]
        ]
    },
    {
        "id": "ffe6fe9d862e8480",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "Iniciar",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1930,
        "y": 2200,
        "wires": [
            [
                "1e7408a44bb6c103"
            ]
        ]
    },
    {
        "id": "1f113caa7dcee4f9",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver en consola",
        "active": true,
        "tosidebar": true,
        "console": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 2300,
        "y": 2260,
        "wires": []
    },
    {
        "id": "316efee7c7e1cbce",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Data Accumulation Node",
        "func": "let lecturas = flow.get(\"lecturasVolumen\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual\nconst registro = {\n    tiempo: Date.now(),\n    volumen: msg.payload // Usar msg.payload directamente\n};\nlecturas.push(registro);\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nconst tiempoActual = Date.now();\nlecturas = lecturas.filter(r => (tiempoActual - r.tiempo) <= tiempoMaximo);\n\n// Guardar las lecturas actualizadas en el contexto del flujo\nflow.set(\"lecturasVolumen\", lecturas);\n\n// Pasar las lecturas completas al siguiente nodo para su procesamiento\nreturn { payload: lecturas };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2430,
        "y": 2940,
        "wires": [
            [
                "ddff9f1fbcfdd1d8"
            ]
        ]
    },
    {
        "id": "ddff9f1fbcfdd1d8",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Detectar Rellenado",
        "func": "const lecturas = msg.payload;\nconst estadoAnterior = flow.get('estadoRellenado') || 'Operaci√≥n Normal';\nlet estadoActual = estadoAnterior;\n\nconst umbralIncremento = 3; // Ajustar seg√∫n necesidad\nconst umbralLecturas = 5;   // N√∫mero de lecturas a considerar\n\nif (lecturas.length >= umbralLecturas) {\n    const volumenAnterior = lecturas[lecturas.length - umbralLecturas].volumen;\n    const volumenActual = lecturas[lecturas.length - 1].volumen;\n    const deltaVolumen = volumenActual - volumenAnterior;\n\n    if (deltaVolumen >= umbralIncremento && estadoAnterior === 'Operaci√≥n Normal') {\n        estadoActual = 'En Rellenado';\n        flow.set('inicioRellenado', Date.now());\n    } else if (deltaVolumen <= -umbralIncremento && estadoAnterior === 'En Rellenado') {\n        estadoActual = 'Operaci√≥n Normal';\n        flow.set('finRellenado', Date.now());\n    }\n}\n\nflow.set('estadoRellenado', estadoActual);\nmsg.payload = estadoActual;\n\n// Actualizar el estado anterior para la pr√≥xima iteraci√≥n\nflow.set('estadoAnterior', estadoActual);\n\nreturn msg;",
        "outputs": 1,
        "x": 2690,
        "y": 2940,
        "wires": [
            [
                "5ce82d5b2a5001b5",
                "d1f8549f846a27b6"
            ]
        ]
    },
    {
        "id": "5ce82d5b2a5001b5",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Filtrar Lecturas No V√°lidas",
        "func": "let estadoRellenado = flow.get('estadoRellenado') || 'Operaci√≥n Normal';\nlet estadoAnterior = flow.get('estadoAnterior') || 'Operaci√≥n Normal';\n\nif (estadoAnterior === 'En Rellenado' && estadoRellenado === 'Operaci√≥n Normal') {\n    // El estado cambi√≥ de 'En Rellenado' a 'Operaci√≥n Normal'\n    let lecturas = flow.get('lecturasVolumen') || [];\n    let inicioRellenado = flow.get('inicioRellenado') || Date.now();\n\n    // Eliminar lecturas durante 'En Rellenado'\n    lecturas = lecturas.filter(registro => registro.tiempo < inicioRellenado);\n\n    flow.set('lecturasVolumen', lecturas);\n}\n\n// Actualizar el estado anterior\nflow.set('estadoAnterior', estadoRellenado);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2980,
        "y": 2900,
        "wires": [
            []
        ]
    },
    {
        "id": "d1f8549f846a27b6",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Calcular Flujo",
        "func": "const lecturas = flow.get(\"lecturasVolumen\") || [];\nconst estadoRellenado = flow.get('estadoRellenado') || 'Operaci√≥n Normal';\n\n// Obtener el √∫ltimo flujo v√°lido almacenado\nlet ultimoFlujoValido = flow.get('ultimoFlujoValido');\n\n// Variable para el flujo actual\nlet flujo = ultimoFlujoValido || 0; // Usar el √∫ltimo flujo v√°lido por defecto\n\n// Verificar el estado actual\nif (estadoRellenado === 'Operaci√≥n Normal') {\n    if (lecturas.length >= 2) {\n        const volumenAnterior = lecturas[lecturas.length - 2].volumen;\n        const tiempoAnterior = lecturas[lecturas.length - 2].tiempo;\n        const volumenActual = lecturas[lecturas.length - 1].volumen;\n        const tiempoActual = lecturas[lecturas.length - 1].tiempo;\n\n        const deltaVolumen = volumenActual - volumenAnterior;\n        const deltaTiempo = (tiempoActual - tiempoAnterior) / 1000; // en segundos\n\n        if (deltaVolumen <= 0) {\n            // Volumen est√° disminuyendo, calcular flujo\n            flujo = -deltaVolumen / deltaTiempo; // flujo positivo\n\n            // Actualizar el √∫ltimo flujo v√°lido\n            ultimoFlujoValido = flujo;\n            flow.set('ultimoFlujoValido', ultimoFlujoValido);\n        } else {\n            // Volumen est√° aumentando, no actualizar flujo ni ultimoFlujoValido\n            flujo = ultimoFlujoValido;\n        }\n    } else {\n        // Si no hay suficientes lecturas, mantener el √∫ltimo flujo v√°lido\n        flujo = ultimoFlujoValido;\n    }\n} else if (estadoRellenado === 'En Rellenado') {\n    // Durante 'En Rellenado', no actualizar 'ultimoFlujoValido' ni recalcular 'flujo'\n    flujo = ultimoFlujoValido;\n}\n\n// Preparar el mensaje de salida\nmsg.payload = {\n    flujo: flujo,\n    estado: estadoRellenado\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2980,
        "y": 2980,
        "wires": [
            [
                "e0e7b068ec907c29",
                "7498251e5c49d511"
            ]
        ]
    },
    {
        "id": "e0e7b068ec907c29",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver Flujo",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.flujo",
        "targetType": "msg",
        "x": 3270,
        "y": 2980,
        "wires": []
    },
    {
        "id": "7498251e5c49d511",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Ver Estado",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.estado",
        "targetType": "msg",
        "x": 3270,
        "y": 3020,
        "wires": []
    },
    {
        "id": "a5eba0d9354df196",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 600,
        "wires": [
            [
                "1c705dd88a048581"
            ]
        ]
    },
    {
        "id": "beab0f227ba17919",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 760,
        "y": 560,
        "wires": [
            [
                "1c705dd88a048581"
            ]
        ]
    },
    {
        "id": "447e42f5f69269b1",
        "type": "change",
        "z": "7bdaf3fb66ecd941",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 980,
        "y": 680,
        "wires": [
            [
                "1c705dd88a048581"
            ]
        ]
    },
    {
        "id": "1c705dd88a048581",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 800,
        "wires": [
            [
                "a695271a7daa18ab"
            ],
            [],
            [
                "7a08f6124a96a570"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "8805d87ed345fefb",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 520,
        "wires": [
            [
                "1c705dd88a048581"
            ]
        ]
    },
    {
        "id": "c5dc980ec8d2f84a",
        "type": "link in",
        "z": "7bdaf3fb66ecd941",
        "name": "link in 4",
        "links": [],
        "x": 795,
        "y": 480,
        "wires": [
            [
                "1c705dd88a048581"
            ]
        ]
    },
    {
        "id": "7a08f6124a96a570",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "50c2a7eaf0dea32e",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 700,
        "y": 1020,
        "wires": [
            [
                "1c705dd88a048581",
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "fbe0927b2537c278",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "calc_presion",
        "func": "const valorADCMin = 4000;\nconst valorADCMax = 20000;\nconst valorMin = 0;\nconst valorMax = 10.1972;\n\nconst valorADC = msg.payload[0];\nconst valorPresion = ((valorADC - valorADCMin) / (valorADCMax - valorADCMin)) * (valorMax - valorMin) + valorMin;\n\nmsg.payload = valorPresion.toFixed(4);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1720,
        "y": 700,
        "wires": [
            [
                "e8484da43f421e27",
                "82b3a920bbcffc2f"
            ]
        ]
    },
    {
        "id": "a695271a7daa18ab",
        "type": "modbus-flex-getter",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "d7770bcbe96d749b",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1200,
        "y": 760,
        "wires": [
            [
                "447e42f5f69269b1",
                "9b13c32a9763fe43"
            ],
            []
        ]
    },
    {
        "id": "9b13c32a9763fe43",
        "type": "switch",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI3",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1430,
        "y": 740,
        "wires": [
            [
                "fbe0927b2537c278"
            ],
            [],
            [],
            []
        ]
    },
    {
        "id": "e8484da43f421e27",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "telemetria",
        "func": "msg.payload = {\n  presion: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1900,
        "y": 700,
        "wires": [
            []
        ]
    },
    {
        "id": "82b3a920bbcffc2f",
        "type": "ui-gauge",
        "z": "7bdaf3fb66ecd941",
        "name": "Presion alimentacion",
        "group": "3f690bb5a526a246",
        "order": 5,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Presi√≥n Alimentaci√≥n",
        "units": "Kg/cm2",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4",
                "color": "#5cd65c"
            },
            {
                "from": "6",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2260,
        "y": 700,
        "wires": []
    },
    {
        "id": "bd78b15616db4f24",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 360,
        "wires": [
            [
                "92a21b04f97c6030"
            ]
        ]
    },
    {
        "id": "ff8de34e860cc5e5",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 400,
        "wires": [
            [
                "b33dfe67674e8386"
            ]
        ]
    },
    {
        "id": "92a21b04f97c6030",
        "type": "change",
        "z": "7bdaf3fb66ecd941",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1010,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "b33dfe67674e8386",
        "type": "change",
        "z": "7bdaf3fb66ecd941",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1030,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "6c5ca6e53e606f0c",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 680,
        "wires": [
            [
                "1c705dd88a048581"
            ]
        ]
    },
    {
        "id": "230d3da4436b7fdf",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 720,
        "wires": [
            [
                "1c705dd88a048581"
            ]
        ]
    },
    {
        "id": "419147ac532a7e41",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_1_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "a0fb1273377baa96",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 800,
        "wires": [
            [
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "e7ceb407f2e2da93",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "Format temp",
        "func": "let temperature = msg.payload;\nmsg.payload = temperature + \"¬∞C\"; // A√±ade la unidad ¬∞C al n√∫mero\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 820,
        "wires": [
            [
                "386902bf1cad5303"
            ]
        ]
    },
    {
        "id": "46de435dbd56fd4c",
        "type": "ui-text",
        "z": "7bdaf3fb66ecd941",
        "group": "9fa25027cf22c16b",
        "order": 1,
        "width": "0",
        "height": "0",
        "name": "Entrada BA-01",
        "label": "Entrada BA-01",
        "format": "{{msg.payload}}",
        "layout": "col-center",
        "style": true,
        "font": "Helvetica, sans-serif",
        "fontSize": 16,
        "color": "#717171",
        "className": "",
        "x": 2220,
        "y": 780,
        "wires": []
    },
    {
        "id": "76aec360334023db",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "Format temp",
        "func": "let temperature = msg.payload;\nmsg.payload = temperature + \"¬∞C\"; // A√±ade la unidad ¬∞C al n√∫mero\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2030,
        "y": 780,
        "wires": [
            [
                "46de435dbd56fd4c"
            ]
        ]
    },
    {
        "id": "386902bf1cad5303",
        "type": "ui-text",
        "z": "7bdaf3fb66ecd941",
        "group": "9fa25027cf22c16b",
        "order": 6,
        "width": 0,
        "height": 0,
        "name": "Salida BA-01",
        "label": "Salida BA-01",
        "format": "{{msg.payload}}",
        "layout": "col-center",
        "style": true,
        "font": "Helvetica, sans-serif",
        "fontSize": 16,
        "color": "#717171",
        "className": "",
        "x": 2230,
        "y": 820,
        "wires": []
    },
    {
        "id": "d6e8f6a8c6186caa",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "calc_temp",
        "func": "const valorADCMin = 4000;\nconst valorADCMax = 20000;\nconst valorMin = 0;\nconst valorMax = 500;\n\nconst valorADC = msg.payload[0];\nconst valorTemperatura = ((valorADC - valorADCMin) / (valorADCMax - valorADCMin)) * (valorMax - valorMin) + valorMin;\n\nmsg.payload = Math.round(valorTemperatura);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 780,
        "wires": [
            [
                "76aec360334023db"
            ]
        ]
    },
    {
        "id": "1dabc1da9d039a01",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "calc_temp",
        "func": "const valorADCMin = 4000;\nconst valorADCMax = 20000;\nconst valorMin = 0;\nconst valorMax = 1300;\n\nconst valorADC = msg.payload[0];\nconst valorTemperatura = ((valorADC - valorADCMin) / (valorADCMax - valorADCMin)) * (valorMax - valorMin) + valorMin;\n\nmsg.payload = Math.round(valorTemperatura);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 820,
        "wires": [
            [
                "e7ceb407f2e2da93"
            ]
        ]
    },
    {
        "id": "b2bb68711bdb4496",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 840,
        "wires": [
            [
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "51064b989ed4de12",
        "type": "modbus-flex-getter",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_2",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e3dc711be64f6be4",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1180,
        "y": 960,
        "wires": [
            [
                "97848aef38844e5e",
                "b17a3a04f8418cf9"
            ],
            []
        ]
    },
    {
        "id": "97848aef38844e5e",
        "type": "change",
        "z": "7bdaf3fb66ecd941",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1040,
        "y": 1140,
        "wires": [
            [
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "c29399c9d8888dc2",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_1_AI5",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI5",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":6,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "a7594131ba8d3918",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_1_AI6",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI8",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":7,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 920,
        "wires": [
            []
        ]
    },
    {
        "id": "b17a3a04f8418cf9",
        "type": "switch",
        "z": "7bdaf3fb66ecd941",
        "name": "ADC_2 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC2_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI5",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI6",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI7",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 8,
        "x": 1430,
        "y": 860,
        "wires": [
            [],
            [],
            [
                "1dabc1da9d039a01"
            ],
            [
                "d6e8f6a8c6186caa"
            ],
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "99fb69245d19c47d",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 1020,
        "wires": [
            [
                "51064b989ed4de12"
            ],
            [],
            [
                "d7a23da26bb99f68"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "d7a23da26bb99f68",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 1080,
        "wires": [
            []
        ]
    },
    {
        "id": "8c3b6f7a3e49f18f",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 700,
        "y": 1320,
        "wires": [
            [
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "f10be57e72a961aa",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 690,
        "y": 1280,
        "wires": [
            [
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "7f2458285e72a356",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 690,
        "y": 1240,
        "wires": [
            [
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "29c847decadea485",
        "type": "link in",
        "z": "7bdaf3fb66ecd941",
        "name": "link in 7",
        "links": [],
        "x": 655,
        "y": 1200,
        "wires": [
            [
                "99fb69245d19c47d"
            ]
        ]
    },
    {
        "id": "aa9459cf4644793c",
        "type": "debug",
        "z": "7bdaf3fb66ecd941",
        "name": "debug 35",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 920,
        "wires": []
    },
    {
        "id": "087c3e77df8d470e",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "Enviar mensaje de prueba",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"text\":\"Este es un mensaje de prueba desde Node-RED usando Whin\"}",
        "payloadType": "json",
        "x": 2030,
        "y": 980,
        "wires": [
            []
        ]
    },
    {
        "id": "a71680783bd50db9",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "Enviar mensaje de prueba",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"text\":\"Este es un mensaje de prueba desde Node-RED usando Whin\"}",
        "payloadType": "json",
        "x": 1950,
        "y": 1080,
        "wires": [
            []
        ]
    },
    {
        "id": "5198e0808347554a",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "",
        "props": [
            {
                "p": "key",
                "v": "<your_rapidapikey_goes_here>",
                "vt": "str"
            },
            {
                "p": "url",
                "v": "http://my.endpoint.com/whin",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1670,
        "y": 1220,
        "wires": [
            [
                "d26b5ca9e9ea9ccd"
            ]
        ]
    },
    {
        "id": "d26b5ca9e9ea9ccd",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "Whin-Receive-Set-URL",
        "func": "msg.method = \"POST\";\nmsg.url = \"https://whin2.p.rapidapi.com/addurl\";\nmsg.headers = {\n    'content-type': 'application/json',\n    'X-RapidAPI-Host': \"whin2.p.rapidapi.com\",\n    'X-RapidAPI-Key': msg.key\n}\nmsg.payload = {\"url\":msg.url}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1890,
        "y": 1220,
        "wires": [
            [
                "acd43a2061497eee"
            ]
        ]
    },
    {
        "id": "acd43a2061497eee",
        "type": "http request",
        "z": "7bdaf3fb66ecd941",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 2130,
        "y": 1220,
        "wires": [
            [
                "dd1c5ad90e9cd7bc"
            ]
        ]
    },
    {
        "id": "dd1c5ad90e9cd7bc",
        "type": "debug",
        "z": "7bdaf3fb66ecd941",
        "name": "debug 26",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 2360,
        "y": 1220,
        "wires": []
    },
    {
        "id": "b01ff5b9.5c8ff8",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "Iniciar solicitud",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1700,
        "y": 1360,
        "wires": [
            [
                "7b34ed34.3f5eb4"
            ]
        ]
    },
    {
        "id": "7b34ed34.3f5eb4",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "Configurar Solicitud",
        "func": "msg.method = \"POST\";\nmsg.url = \"https://whin2.p.rapidapi.com/send\";\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'x-rapidapi-host': \"whin2.p.rapidapi.com\",\n    'x-rapidapi-key': '4fd095e525msh99b661699421a28p1b997ejsn4a6f974bbf31'\n};\nmsg.payload = {\"text\":\"ALERTAAAAAAAAAAAAA!\"};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1930,
        "y": 1360,
        "wires": [
            [
                "3f96c6e2.3b14fa"
            ]
        ]
    },
    {
        "id": "3f96c6e2.3b14fa",
        "type": "http request",
        "z": "7bdaf3fb66ecd941",
        "name": "Enviar a Whin",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 2140,
        "y": 1360,
        "wires": [
            [
                "84758bca.9d71a8"
            ]
        ]
    },
    {
        "id": "84758bca.9d71a8",
        "type": "debug",
        "z": "7bdaf3fb66ecd941",
        "name": "Respuesta",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 2340,
        "y": 1360,
        "wires": []
    },
    {
        "id": "df6144f568d3c9ce",
        "type": "inject",
        "z": "7bdaf3fb66ecd941",
        "name": "Iniciar solicitud",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1760,
        "y": 1500,
        "wires": [
            [
                "cfcdc7c86366225b"
            ]
        ]
    },
    {
        "id": "cfcdc7c86366225b",
        "type": "function",
        "z": "7bdaf3fb66ecd941",
        "name": "Configurar Solicitud",
        "func": "msg.headers = {\n    'x-rapidapi-host': 'whin2.p.rapidapi.com',\n    'x-rapidapi-key': '4fd095e525msh99b661699421a28p1b997ejsn4a6f974bbf31'\n};\n\nmsg.method = 'GET';\nmsg.url = 'https://whin2.p.rapidapi.com/getqr';\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1990,
        "y": 1500,
        "wires": [
            [
                "bd358822cfc5d8c9"
            ]
        ]
    },
    {
        "id": "bd358822cfc5d8c9",
        "type": "http request",
        "z": "7bdaf3fb66ecd941",
        "name": "Enviar a Whin",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 2200,
        "y": 1500,
        "wires": [
            [
                "dc3121741a782153"
            ]
        ]
    },
    {
        "id": "dc3121741a782153",
        "type": "debug",
        "z": "7bdaf3fb66ecd941",
        "name": "Respuesta",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 2400,
        "y": 1500,
        "wires": []
    },
    {
        "id": "ee5c0feac48a805e",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "ADC4_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC4_AI0",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":40,\"quantity\":1}",
        "payloadType": "json",
        "x": 350,
        "y": 440,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "0194ea44a6c0d08e",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 390,
        "y": 400,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "a0aa76c713ce1f4a",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 400,
        "y": 360,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "876d17bd69b07a3b",
        "type": "change",
        "z": "79b057876d37bdc0",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 690,
        "y": 460,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "44e743ce99b66e5d",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 580,
        "wires": [
            [
                "3b3a645b7ae7eaa2"
            ],
            [],
            [
                "ead203313f189036"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "096d24048177f4b0",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 400,
        "y": 320,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "5dce2eff2ced62c0",
        "type": "link in",
        "z": "79b057876d37bdc0",
        "name": "link in 6",
        "links": [],
        "x": 435,
        "y": 280,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "ead203313f189036",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "6bbb9650f9e44dd8",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 410,
        "y": 900,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "7b40cfce1aa1b23d",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "ADC4_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC4_AI1",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":41,\"quantity\":1}",
        "payloadType": "json",
        "x": 350,
        "y": 480,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "95199eaf5637020c",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "ADC4_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC4_AI2",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":42,\"quantity\":1}",
        "payloadType": "json",
        "x": 350,
        "y": 520,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "3b3a645b7ae7eaa2",
        "type": "modbus-flex-getter",
        "z": "79b057876d37bdc0",
        "name": "ADC4",
        "showStatusActivities": true,
        "showErrors": true,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "aa49ccb7cd13b90a",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 830,
        "y": 560,
        "wires": [
            [
                "b9bdf817a2fdf78c",
                "876d17bd69b07a3b"
            ],
            []
        ]
    },
    {
        "id": "b9bdf817a2fdf78c",
        "type": "switch",
        "z": "79b057876d37bdc0",
        "name": "ADC4 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC4_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC4_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC4_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC4_AI3",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1090,
        "y": 460,
        "wires": [
            [
                "020e7222aa32e2f6"
            ],
            [
                "2d722252550b24bd"
            ],
            [
                "c99df9926c487646"
            ],
            [
                "93b694912ea091f3"
            ]
        ]
    },
    {
        "id": "61ec9e162884e9ee",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "ADC4_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC4_AI3",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":43,\"quantity\":1}",
        "payloadType": "json",
        "x": 350,
        "y": 560,
        "wires": [
            [
                "44e743ce99b66e5d"
            ]
        ]
    },
    {
        "id": "c99df9926c487646",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "calc temp",
        "func": "let temperature = msg.payload;\nmsg.payload = (temperature * 0.1).toFixed(1);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 540,
        "wires": [
            [
                "c4e00cfbdc3f28e4",
                "9463bb42a7998814",
                "60177ae18622dad4"
            ]
        ]
    },
    {
        "id": "63cd430c4ad14430",
        "type": "ui-text",
        "z": "79b057876d37bdc0",
        "group": "9dee42aba81f471c",
        "order": 6,
        "width": "2",
        "height": "1",
        "name": "Salida Asfalto",
        "label": "Salida Asfalto",
        "format": "{{msg.payload}}",
        "layout": "row-left",
        "style": true,
        "font": "Helvetica, sans-serif",
        "fontSize": 16,
        "color": "#717171",
        "className": "",
        "x": 1760,
        "y": 540,
        "wires": []
    },
    {
        "id": "c4e00cfbdc3f28e4",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Format temp",
        "func": "let temperature = msg.payload;\nmsg.payload = temperature + \"¬∞C\"; // A√±ade la unidad ¬∞C al n√∫mero\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 540,
        "wires": [
            [
                "63cd430c4ad14430"
            ]
        ]
    },
    {
        "id": "9463bb42a7998814",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "telemetria",
        "func": "msg.payload = {\n  temperatura: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1600,
        "y": 540,
        "wires": [
            [
                "965851e54899ecb0"
            ]
        ]
    },
    {
        "id": "965851e54899ecb0",
        "type": "mqtt out",
        "z": "79b057876d37bdc0",
        "d": true,
        "name": "mqtt_tb_ST-4.1",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "9c8d857bf03439f0",
        "x": 1960,
        "y": 540,
        "wires": []
    },
    {
        "id": "2d722252550b24bd",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "calc temp",
        "func": "let temperature = msg.payload;\nmsg.payload = (temperature * 0.1).toFixed(1);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 440,
        "wires": [
            [
                "daa907b8111a6aca",
                "87d5236efe06994a",
                "8d7876a51b9f0410"
            ]
        ]
    },
    {
        "id": "463d11b907270837",
        "type": "ui-text",
        "z": "79b057876d37bdc0",
        "group": "9dee42aba81f471c",
        "order": 6,
        "width": "2",
        "height": "1",
        "name": "Salida HCD",
        "label": "Salida HCD",
        "format": "{{msg.payload}}",
        "layout": "row-left",
        "style": true,
        "font": "Helvetica, sans-serif",
        "fontSize": 16,
        "color": "#717171",
        "className": "",
        "x": 1750,
        "y": 440,
        "wires": []
    },
    {
        "id": "daa907b8111a6aca",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Format temp",
        "func": "let temperature = msg.payload;\nmsg.payload = temperature + \"¬∞C\";\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 440,
        "wires": [
            [
                "463d11b907270837"
            ]
        ]
    },
    {
        "id": "87d5236efe06994a",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "telemetria",
        "func": "msg.payload = {\n  temperatura: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1600,
        "y": 440,
        "wires": [
            [
                "cb63d00e22186e68"
            ]
        ]
    },
    {
        "id": "cb63d00e22186e68",
        "type": "mqtt out",
        "z": "79b057876d37bdc0",
        "d": true,
        "name": "mqtt_tb_ST-4.2",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "374271799f2080bb",
        "x": 1960,
        "y": 440,
        "wires": []
    },
    {
        "id": "020e7222aa32e2f6",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "calc temp",
        "func": "let temperature = msg.payload;\nmsg.payload = (temperature * 0.1).toFixed(1);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 320,
        "wires": [
            [
                "43fba3a520041436",
                "2533a16c763d9d1e"
            ]
        ]
    },
    {
        "id": "d0c7e01fe2f4c79a",
        "type": "ui-text",
        "z": "79b057876d37bdc0",
        "group": "9dee42aba81f471c",
        "order": 6,
        "width": "2",
        "height": "1",
        "name": "Entrada Residuo",
        "label": "Entrada Residuo",
        "format": "{{msg.payload}}",
        "layout": "row-left",
        "style": true,
        "font": "Helvetica, sans-serif",
        "fontSize": 16,
        "color": "#717171",
        "className": "",
        "x": 1770,
        "y": 320,
        "wires": []
    },
    {
        "id": "43fba3a520041436",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Format temp",
        "func": "let temperature = msg.payload;\nmsg.payload = temperature + \"¬∞C\"; // A√±ade la unidad ¬∞C al n√∫mero\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 320,
        "wires": [
            [
                "d0c7e01fe2f4c79a"
            ]
        ]
    },
    {
        "id": "2533a16c763d9d1e",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "telemetria",
        "func": "msg.payload = {\n  temperatura: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1600,
        "y": 320,
        "wires": [
            [
                "5041f88229c61fec"
            ]
        ]
    },
    {
        "id": "5041f88229c61fec",
        "type": "mqtt out",
        "z": "79b057876d37bdc0",
        "d": true,
        "name": "mqtt_tb_ST-4.3",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f9afc8173d9cc7da",
        "x": 1960,
        "y": 320,
        "wires": []
    },
    {
        "id": "93b694912ea091f3",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "calc temp",
        "func": "let temperature = msg.payload;\nmsg.payload = (temperature * 0.1).toFixed(1);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 580,
        "wires": [
            [
                "ba9088b55486d51d",
                "36daa68d74dd4708"
            ]
        ]
    },
    {
        "id": "4e108b4a40bd171f",
        "type": "ui-text",
        "z": "79b057876d37bdc0",
        "group": "9dee42aba81f471c",
        "order": 6,
        "width": "2",
        "height": "1",
        "name": "Salida Residuo",
        "label": "Salida Residuo",
        "format": "{{msg.payload}}",
        "layout": "row-left",
        "style": true,
        "font": "Helvetica, sans-serif",
        "fontSize": 16,
        "color": "#717171",
        "className": "",
        "x": 1760,
        "y": 580,
        "wires": []
    },
    {
        "id": "ba9088b55486d51d",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Format temp",
        "func": "let temperature = msg.payload;\nmsg.payload = temperature + \"¬∞C\"; // A√±ade la unidad ¬∞C al n√∫mero\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 580,
        "wires": [
            [
                "4e108b4a40bd171f"
            ]
        ]
    },
    {
        "id": "36daa68d74dd4708",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "telemetria",
        "func": "msg.payload = {\n  temperatura: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1600,
        "y": 580,
        "wires": [
            [
                "21513c9152026d88"
            ]
        ]
    },
    {
        "id": "21513c9152026d88",
        "type": "mqtt out",
        "z": "79b057876d37bdc0",
        "d": true,
        "name": "mqtt_tb_ST-4.4",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "6a688c0112ac638b",
        "x": 1970,
        "y": 580,
        "wires": []
    },
    {
        "id": "hcd_temp_switch",
        "type": "switch",
        "z": "79b057876d37bdc0",
        "name": "Verificar alerta",
        "property": "alert",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "high",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1660,
        "y": 400,
        "wires": [
            [
                "prepare_whin_alert"
            ],
            []
        ]
    },
    {
        "id": "prepare_whin_alert",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Preparar alerta Whin",
        "func": "msg.method = \"POST\";\nmsg.url = \"https://whin2.p.rapidapi.com/send\";\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'x-rapidapi-host': \"whin2.p.rapidapi.com\",\n    'x-rapidapi-key': '4fd095e525msh99b661699421a28p1b997ejsn4a6f974bbf31'\n};\nmsg.payload = {\n    \"text\": `ALERTA: Temperatura alta en Salida HCD. Temperatura actual: ${msg.temperature}¬∞C`\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1870,
        "y": 400,
        "wires": [
            [
                "send_whin_alert"
            ]
        ]
    },
    {
        "id": "send_whin_alert",
        "type": "http request",
        "z": "79b057876d37bdc0",
        "name": "Enviar alerta Whin",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 2100,
        "y": 400,
        "wires": [
            [
                "debug_whin_response"
            ]
        ]
    },
    {
        "id": "debug_whin_response",
        "type": "debug",
        "z": "79b057876d37bdc0",
        "name": "Respuesta Whin",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2310,
        "y": 400,
        "wires": []
    },
    {
        "id": "3e523f266665daf1",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "calc temp HCD con alerta",
        "func": "function calcTempHCDWithAlert(msg) {\n    // Asegurarse de que msg.payload existe y es un n√∫mero\n    if (typeof msg.payload === 'undefined' || msg.payload === null) {\n        return { payload: { error: \"Payload is undefined or null\" } };\n    }\n\n    let temperature = Number(msg.payload);\n    \n    // Verificar si la conversi√≥n a n√∫mero fue exitosa\n    if (isNaN(temperature)) {\n        return { payload: { error: \"Payload is not a valid number\" } };\n    }\n\n    let calculatedTemp = Number((temperature * 0.1).toFixed(1));\n\n    let result = {\n        payload: {\n            temperature: calculatedTemp,\n            alert: null\n        }\n    };\n\n    if (calculatedTemp > 50) {\n        result.payload.alert = \"high\";\n    }\n\n    return result;\n}\n\n// Uso de la funci√≥n\nreturn calcTempHCDWithAlert(msg);",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1090,
        "y": 780,
        "wires": [
            [
                "b70afaf377408b53",
                "ddd9f456233fb84e"
            ]
        ]
    },
    {
        "id": "b70afaf377408b53",
        "type": "switch",
        "z": "79b057876d37bdc0",
        "name": "Verificar alerta",
        "property": "payload.alert",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "high",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1300,
        "y": 780,
        "wires": [
            [
                "e64867630a5dfc51"
            ],
            []
        ]
    },
    {
        "id": "e64867630a5dfc51",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Preparar alerta Whin",
        "func": "msg.method = \"POST\";\nmsg.url = \"https://whin2.p.rapidapi.com/send2group\";\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'x-rapidapi-host': \"whin2.p.rapidapi.com\",\n    'x-rapidapi-key': '4fd095e525msh99b661699421a28p1b997ejsn4a6f974bbf31'\n};\nmsg.payload = {\n    \"gid\": \"120363337404279077\",\n    \"text\": `ALERTA: Temperatura alta en Salida HCD. Temperatura actual: ${msg.payload.temperature}¬∞C`\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1520,
        "y": 760,
        "wires": [
            [
                "cca07f098b279958"
            ]
        ]
    },
    {
        "id": "cca07f098b279958",
        "type": "http request",
        "z": "79b057876d37bdc0",
        "name": "Enviar alerta Whin",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1750,
        "y": 760,
        "wires": [
            [
                "f739b92b53e7e7ac"
            ]
        ]
    },
    {
        "id": "f739b92b53e7e7ac",
        "type": "debug",
        "z": "79b057876d37bdc0",
        "name": "Respuesta Whin",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 1950,
        "y": 760,
        "wires": []
    },
    {
        "id": "ab10af511be453b1",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "550",
        "payloadType": "num",
        "x": 910,
        "y": 780,
        "wires": [
            [
                "3e523f266665daf1",
                "f55fd722752e44a6"
            ]
        ]
    },
    {
        "id": "ddd9f456233fb84e",
        "type": "debug",
        "z": "79b057876d37bdc0",
        "name": "debug 96",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 860,
        "wires": []
    },
    {
        "id": "8d7876a51b9f0410",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Alerta temp ST-4.2",
        "func": "function checkHCDAlert(msg) {\n    let temperature = Number(msg.payload);\n\n    if (isNaN(temperature)) {\n        msg.error = \"La temperatura no es un n√∫mero v√°lido\";\n        return msg;\n    }\n\n    // Guardamos la temperatura en msg.temperature para uso posterior\n    msg.temperature = temperature;\n    \n    // Definir la alerta\n    msg.alert = temperature > 50 ? \"high\" : null;\n\n    return msg;\n}\n\nreturn checkHCDAlert(msg);",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 400,
        "wires": [
            [
                "hcd_temp_switch"
            ]
        ]
    },
    {
        "id": "60177ae18622dad4",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Alerta temp ST-4.1",
        "func": "function checkHCDAlert(msg) {\n    let temperature = Number(msg.payload);\n\n    if (isNaN(temperature)) {\n        msg.error = \"La temperatura no es un n√∫mero v√°lido\";\n        return msg;\n    }\n\n    // Guardamos la temperatura en msg.temperature para uso posterior\n    msg.temperature = temperature;\n    \n    // Definir la alerta\n    msg.alert = temperature > 260 ? \"high\" : null;\n\n    return msg;\n}\n\nreturn checkHCDAlert(msg);",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1330,
        "y": 500,
        "wires": [
            [
                "b87204f534086dbe"
            ]
        ]
    },
    {
        "id": "b87204f534086dbe",
        "type": "switch",
        "z": "79b057876d37bdc0",
        "name": "Verificar alerta",
        "property": "alert",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "high",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1520,
        "y": 500,
        "wires": [
            [
                "5877524c053231bb"
            ],
            []
        ]
    },
    {
        "id": "5877524c053231bb",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Preparar alerta Whin",
        "func": "msg.method = \"POST\";\nmsg.url = \"https://whin2.p.rapidapi.com/send\";\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'x-rapidapi-host': \"whin2.p.rapidapi.com\",\n    'x-rapidapi-key': '4fd095e525msh99b661699421a28p1b997ejsn4a6f974bbf31'\n};\nmsg.payload = {\n    \"text\": `ALERTA: Temperatura alta en Salida HCD. Temperatura actual: ${msg.temperature}¬∞C`\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1720,
        "y": 500,
        "wires": [
            [
                "c9718fd233235a48"
            ]
        ]
    },
    {
        "id": "c9718fd233235a48",
        "type": "http request",
        "z": "79b057876d37bdc0",
        "name": "Enviar alerta Whin",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1930,
        "y": 500,
        "wires": [
            [
                "ad4b7a3673672f70"
            ]
        ]
    },
    {
        "id": "ad4b7a3673672f70",
        "type": "debug",
        "z": "79b057876d37bdc0",
        "name": "Respuesta Whin",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2120,
        "y": 500,
        "wires": []
    },
    {
        "id": "f55fd722752e44a6",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "calc temp",
        "func": "let temperature = msg.payload;\nmsg.payload = (temperature * 0.1).toFixed(1);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 1060,
        "wires": [
            [
                "269597ba27b6df3a"
            ]
        ]
    },
    {
        "id": "269597ba27b6df3a",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Hist√©resis",
        "func": "const activationThreshold = 55;\nconst deactivationThreshold = 52;\n\nlet temperature = Number(msg.payload);\nlet currentState = flow.get('alarmState') || 'normal';\n\nif (currentState === 'normal' && temperature >= activationThreshold) {\n    flow.set('alarmState', 'alarm');\n    msg.alarmState = 'alarm';\n} else if (currentState === 'alarm' && temperature <= deactivationThreshold) {\n    flow.set('alarmState', 'normal');\n    msg.alarmState = 'normal';\n} else {\n    msg.alarmState = currentState;\n}\n\nmsg.temperature = temperature;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "x": 1300,
        "y": 1060,
        "wires": [
            [
                "7289a2b453623165"
            ]
        ]
    },
    {
        "id": "7289a2b453623165",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Latching",
        "func": "let alarmActive = flow.get('alarmActive') || false;\nlet alarmAcknowledged = flow.get('alarmAcknowledged') || false;\n\nif (msg.alarmState === 'alarm' && !alarmActive) {\n    alarmActive = true;\n    alarmAcknowledged = false;\n    flow.set('alarmActive', true);\n    flow.set('alarmAcknowledged', false);\n    msg.triggerAlert = true;\n} else if (msg.alarmState === 'normal' && alarmActive) {\n    alarmActive = false;\n    flow.set('alarmActive', false);\n} else {\n    msg.triggerAlert = false;\n}\n\nmsg.alarmActive = alarmActive;\nmsg.alarmAcknowledged = alarmAcknowledged;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 1060,
        "wires": [
            [
                "bac6564d4d5219a5"
            ]
        ]
    },
    {
        "id": "bac6564d4d5219a5",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Escalonamiento",
        "func": "const escalationLevels = {\n    0: { time: 0, action: 'dashboard' },\n    1: { time: 5 * 60 * 1000, action: 'email' },\n    2: { time: 15 * 60 * 1000, action: 'call' }\n};\n\nif (msg.triggerAlert) {\n    flow.set('alertStartTime', Date.now());\n    msg.escalationLevel = 0;\n    msg.escalationAction = escalationLevels[0].action;\n} else if (msg.alarmActive && !msg.alarmAcknowledged) {\n    let alertStartTime = flow.get('alertStartTime');\n    let timeSinceAlert = Date.now() - alertStartTime;\n    \n    for (let level = Object.keys(escalationLevels).length - 1; level >= 0; level--) {\n        if (timeSinceAlert >= escalationLevels[level].time) {\n            msg.escalationLevel = level;\n            msg.escalationAction = escalationLevels[level].action;\n            break;\n        }\n    }\n} else {\n    msg.escalationLevel = null;\n    msg.escalationAction = null;\n}\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "x": 1640,
        "y": 1060,
        "wires": [
            [
                "6d7802b5a5e9b1fc"
            ]
        ]
    },
    {
        "id": "6d7802b5a5e9b1fc",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Rate Limiting",
        "func": "const maxAlertsPerHour = 3;\nconst hourInMs = 60 * 60 * 1000;\n\nlet alertHistory = flow.get('alertHistory') || [];\nlet currentTime = Date.now();\n\n// Limpiar historial de m√°s de una hora\nalertHistory = alertHistory.filter(time => currentTime - time < hourInMs);\n\nif (msg.escalationAction === 'call') {\n    if (alertHistory.length < maxAlertsPerHour) {\n        alertHistory.push(currentTime);\n        msg.sendAlert = true;\n    } else {\n        msg.sendAlert = false;\n    }\n} else {\n    msg.sendAlert = true;\n}\n\nflow.set('alertHistory', alertHistory);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 1060,
        "wires": [
            [
                "6e077794196ee920"
            ]
        ]
    },
    {
        "id": "6e077794196ee920",
        "type": "switch",
        "z": "79b057876d37bdc0",
        "name": "Routing de Alertas",
        "property": "escalationAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "dashboard",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "email",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "call",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 2020,
        "y": 1060,
        "wires": [
            [
                "77d59cb7dd51d8cf"
            ],
            [
                "da44537352533279"
            ],
            [
                "c3b5294992dbe84b"
            ]
        ]
    },
    {
        "id": "77d59cb7dd51d8cf",
        "type": "ui_text",
        "z": "79b057876d37bdc0",
        "group": "1ae19fd8375bb2f1",
        "order": 7,
        "width": "4",
        "height": "1",
        "name": "Alerta Dashboard",
        "label": "Alerta",
        "format": "{{msg.payload}}",
        "layout": "row-spread",
        "className": "",
        "style": false,
        "font": "",
        "fontSize": "",
        "color": "#000000",
        "x": 2220,
        "y": 1020,
        "wires": []
    },
    {
        "id": "c3b5294992dbe84b",
        "type": "function",
        "z": "79b057876d37bdc0",
        "name": "Preparar alerta Whin",
        "func": "if (msg.sendAlert) {\n    msg.method = \"POST\";\n    msg.url = \"https://whin2.p.rapidapi.com/send\";\n    msg.headers = {\n        'Content-Type': 'application/json',\n        'x-rapidapi-host': \"whin2.p.rapidapi.com\",\n        'x-rapidapi-key': '4fd095e525msh99b661699421a28p1b997ejsn4a6f974bbf31'\n    };\n    msg.payload = {\n        \"text\": `ALERTA CR√çTICA: Temperatura alta en Salida HCD. Temperatura actual: ${msg.temperature}¬∞C`\n    };\n    return msg;\n} else {\n    return null;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2230,
        "y": 1100,
        "wires": [
            [
                "34d6b1f9d1e45b11"
            ]
        ]
    },
    {
        "id": "34d6b1f9d1e45b11",
        "type": "http request",
        "z": "79b057876d37bdc0",
        "name": "Enviar alerta Whin",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 2440,
        "y": 1100,
        "wires": [
            [
                "a9bee28f3b3bb886"
            ]
        ]
    },
    {
        "id": "a9bee28f3b3bb886",
        "type": "debug",
        "z": "79b057876d37bdc0",
        "name": "Debug Whin Response",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2660,
        "y": 1100,
        "wires": []
    },
    {
        "id": "da44537352533279",
        "type": "e-mail",
        "z": "79b057876d37bdc0",
        "server": "smtp.gmail.com",
        "port": "465",
        "authtype": "BASIC",
        "saslformat": true,
        "token": "oauth2Response.access_token",
        "secure": true,
        "tls": true,
        "name": "jorgeosuna87@gmail.com, contacto@riggex.pro",
        "dname": "alerta",
        "x": 2210,
        "y": 1060,
        "wires": []
    },
    {
        "id": "c1a50bcb.dfbcc8",
        "type": "inject",
        "z": "79b057876d37bdc0",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "test",
        "payload": "Este es un mensaje de prueba desde Node-RED.",
        "payloadType": "str",
        "x": 1370,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "1f30eb78f194d9ca",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 600,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "a31dde7ce0e30862",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 760,
        "y": 560,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "a472a1734947289c",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 980,
        "y": 680,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "062df54b04d197ff",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 800,
        "wires": [
            [
                "23232c135f8e6b5a"
            ],
            [],
            [
                "a4705d1e3a89392f"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "a8c51c9d0b619cdc",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 520,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "408de84643012839",
        "type": "link in",
        "z": "af01d920764bfaad",
        "name": "link in 4",
        "links": [],
        "x": 795,
        "y": 480,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "a4705d1e3a89392f",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "012027d473d6521d",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 700,
        "y": 1020,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "ab64f0964e5e02ae",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor num√©rico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1720,
        "y": 720,
        "wires": [
            [
                "01c168ff08cce4d1",
                "f2c6ab67f46d5b67"
            ]
        ]
    },
    {
        "id": "9c089a7dda635f9b",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// A√±adir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no est√° disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros m√°s antiguos que el tiempo m√°ximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1650,
        "y": 420,
        "wires": [
            [
                "58536cb7a3b15a6f"
            ]
        ]
    },
    {
        "id": "58536cb7a3b15a6f",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Flow Calculation Node",
        "func": "const cola = msg.payload;\nlet flujo = 0;\n\n// Obtener el estado del mensaje\nlet estado = msg.estado || flow.get(\"estado\");\n\n// Obtener las lecturas de volumen y tiempo\nlet volumenes = cola.map(registro => registro.volumen);\nlet tiempos = cola.map(registro => registro.tiempo);\n\n// Funci√≥n para calcular el flujo\nfunction calcularFlujo(cola) {\n    if (cola.length > 1) {\n        const primerRegistro = cola[0];\n        const ultimoRegistro = cola[cola.length - 1];\n        const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n        // Convertir los valores de volumen seg√∫n la escala proporcionada\n        const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n        const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n        if (tiempoDiferencia > 0) {\n            let flujoCalculado = Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600); // calcular flujo\n            return flujoCalculado;\n        } else {\n            return 0;\n        }\n    } else {\n        return 0;\n    }\n}\n\n// Variable para almacenar los flujos v√°lidos\nlet flujosRecientes = flow.get(\"flujosRecientes\") || [];\n\nif (estado === \"Relleno\") {\n    // Usar el promedio de los √∫ltimos flujos v√°lidos\n    if (flujosRecientes.length > 0) {\n        let sumaFlujos = flujosRecientes.reduce((a, b) => a + b, 0);\n        flujo = Math.round(sumaFlujos / flujosRecientes.length);\n    } else {\n        flujo = 0; // Si no hay flujos v√°lidos, establecer flujo en cero\n    }\n    node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando flujo promedio\"});\n} else if (estado === \"Alimentaci√≥n\") {\n    // Calcular el flujo normalmente\n    flujo = calcularFlujo(cola);\n\n    // Almacenar el flujo si es v√°lido\n    if (flujo > 0 && flujo <= 10000) {\n        flujosRecientes.push(flujo);\n        if (flujosRecientes.length > 10) flujosRecientes.shift(); // Mantener solo los √∫ltimos 10 flujos\n        flow.set(\"flujosRecientes\", flujosRecientes);\n    }\n\n    node.status({fill:\"green\", shape:\"dot\", text:\"Alimentaci√≥n - Flujo calculado\"});\n} else if (estado === \"Estable\") {\n    flujo = 0; // Sistema detenido o estable\n    node.status({fill:\"blue\", shape:\"ring\", text:\"Sistema Estable - Flujo cero\"});\n} else {\n    // Estado desconocido, usar el √∫ltimo flujo v√°lido si est√° disponible\n    if (flujosRecientes.length > 0) {\n        flujo = flujosRecientes[flujosRecientes.length - 1];\n    } else {\n        flujo = 0;\n    }\n    node.status({fill:\"red\", shape:\"dot\", text:\"Estado Desconocido\"});\n}\n\n// Devolver el valor del flujo\nreturn { payload: flujo };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1880,
        "y": 420,
        "wires": [
            [
                "148463c2fa7134d4",
                "d8962b1866d99142",
                "a2e39a5ef28dff56"
            ]
        ]
    },
    {
        "id": "148463c2fa7134d4",
        "type": "debug",
        "z": "af01d920764bfaad",
        "name": "Flujo COPE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2550,
        "y": 420,
        "wires": []
    },
    {
        "id": "23232c135f8e6b5a",
        "type": "modbus-flex-getter",
        "z": "af01d920764bfaad",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1200,
        "y": 760,
        "wires": [
            [
                "a472a1734947289c",
                "ccf147ea72351c9b"
            ],
            []
        ]
    },
    {
        "id": "ccf147ea72351c9b",
        "type": "switch",
        "z": "af01d920764bfaad",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI3",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1430,
        "y": 740,
        "wires": [
            [],
            [
                "ab64f0964e5e02ae",
                "9c089a7dda635f9b"
            ],
            [],
            []
        ]
    },
    {
        "id": "d8962b1866d99142",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "telemetria",
        "func": "msg.payload = {\n  flujo: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2060,
        "y": 420,
        "wires": [
            [
                "89773a5e4c146ef3"
            ]
        ]
    },
    {
        "id": "01c168ff08cce4d1",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1860,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "89773a5e4c146ef3",
        "type": "mqtt out",
        "z": "af01d920764bfaad",
        "name": "mqtt_flujocope",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f344d91a44765e3a",
        "x": 2380,
        "y": 420,
        "wires": []
    },
    {
        "id": "a2e39a5ef28dff56",
        "type": "ui-gauge",
        "z": "af01d920764bfaad",
        "d": true,
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2210,
        "y": 420,
        "wires": []
    },
    {
        "id": "195e895ddd3fa9d3",
        "type": "ui-chart",
        "z": "af01d920764bfaad",
        "d": true,
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02",
        "label": "Volumen FA-02",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 2160,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "f2c6ab67f46d5b67",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 720,
        "wires": [
            [
                "195e895ddd3fa9d3"
            ]
        ]
    },
    {
        "id": "e3eca2230c43633f",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 360,
        "wires": [
            [
                "ac33332ec1f5f7b2"
            ]
        ]
    },
    {
        "id": "7d815c6dfd8bbb55",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 400,
        "wires": [
            [
                "7aa9f19aa373b5ed"
            ]
        ]
    },
    {
        "id": "ac33332ec1f5f7b2",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1010,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "7aa9f19aa373b5ed",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1030,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "7d33460879264b65",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 680,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "22e8dd95df082bc3",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 720,
        "wires": [
            [
                "062df54b04d197ff"
            ]
        ]
    },
    {
        "id": "955f5f0d5bde828c",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "e7567596bdc9a4a3",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "5280012014f92f61",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 840,
        "wires": [
            []
        ]
    },
    {
        "id": "c001ca3805a4fed3",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI5",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI5",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":6,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "7dc86337da66f242",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1540,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "4799fec766907414",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 650,
        "y": 1500,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "31da9be955f9c772",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 870,
        "y": 1620,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "7bf5b077a2a9fe17",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 1740,
        "wires": [
            [
                "e7e789c35e8b8c7e"
            ],
            [],
            [
                "905ade90b9e89a06"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "eb7290b62f556dca",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1460,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "b5cc801b9ac57930",
        "type": "link in",
        "z": "af01d920764bfaad",
        "name": "link in 56",
        "links": [],
        "x": 685,
        "y": 1420,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "905ade90b9e89a06",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "822fd0239a245028",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 580,
        "y": 1740,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "01a19f228418413c",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor num√©rico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 1680,
        "wires": [
            [
                "0128dfa2ed4faa66",
                "6087e9177f3f5a92"
            ]
        ]
    },
    {
        "id": "e7e789c35e8b8c7e",
        "type": "modbus-flex-getter",
        "z": "af01d920764bfaad",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1090,
        "y": 1700,
        "wires": [
            [
                "31da9be955f9c772",
                "d760db1b9f7dacf6"
            ],
            []
        ]
    },
    {
        "id": "d760db1b9f7dacf6",
        "type": "switch",
        "z": "af01d920764bfaad",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1320,
        "y": 1680,
        "wires": [
            [],
            [
                "01a19f228418413c",
                "a8aec0f71c90abee"
            ],
            []
        ]
    },
    {
        "id": "0128dfa2ed4faa66",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1700,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "0c5fe9804ff575ac",
        "type": "ui-chart",
        "z": "af01d920764bfaad",
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02 1",
        "label": "Volumen FA-02 1",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 2010,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "6087e9177f3f5a92",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1850,
        "y": 1680,
        "wires": [
            [
                "0c5fe9804ff575ac"
            ]
        ]
    },
    {
        "id": "abb9a4b9c51d01b8",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 720,
        "y": 1300,
        "wires": [
            [
                "a84e74aebd52b038"
            ]
        ]
    },
    {
        "id": "703fa083d37be1eb",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 720,
        "y": 1340,
        "wires": [
            [
                "1ca7c6f90be8dd9c"
            ]
        ]
    },
    {
        "id": "a84e74aebd52b038",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 900,
        "y": 1300,
        "wires": [
            []
        ]
    },
    {
        "id": "1ca7c6f90be8dd9c",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 920,
        "y": 1340,
        "wires": [
            []
        ]
    },
    {
        "id": "c3353d295ace118c",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 600,
        "y": 1620,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "074d3219ce10bd3b",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 600,
        "y": 1660,
        "wires": [
            [
                "7bf5b077a2a9fe17"
            ]
        ]
    },
    {
        "id": "9588d27ab190dfc7",
        "type": "ui-gauge",
        "z": "af01d920764bfaad",
        "name": "Flujo COPE 1",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE 1",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2310,
        "y": 1580,
        "wires": []
    },
    {
        "id": "a8aec0f71c90abee",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Acumulaci√≥n de Datos y Detecci√≥n de Estado",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst INICIO_AUMENTO_KEY = \"inicioAumento\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction detectarInicioAumento(cola, umbralAlcanzado) {\n    for (let i = cola.length - 1; i > 0; i--) {\n        if (cola[i].volumen <= cola[i-1].volumen) {\n            return { tiempo: cola[i].tiempo, indice: i };\n        }\n        if (cola[i].tiempo <= umbralAlcanzado) {\n            return { tiempo: cola[i].tiempo, indice: i };\n        }\n    }\n    return { tiempo: cola[0].tiempo, indice: 0 };\n}\n\nfunction calcularPromedioAnterior(cola, indiceInicio) {\n    const lecturasPrevias = cola.slice(0, indiceInicio);\n    if (lecturasPrevias.length === 0) return 0;\n    const suma = lecturasPrevias.reduce((acc, lectura) => acc + lectura.volumen, 0);\n    return suma / lecturasPrevias.length;\n}\n\nfunction detectarCambioVolumen(ultimoVolumen, nuevoVolumen) {\n    if (nuevoVolumen > ultimoVolumen + 70) return \"rellenando\";\n    if (nuevoVolumen < ultimoVolumen - 5) return \"vaciando\";\n    return \"estable\";\n}\n\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\nlet inicioAumento = flow.get(INICIO_AUMENTO_KEY) || null;\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || msg.payload;\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\nconst nuevoEstado = detectarCambioVolumen(ultimoVolumen, nuevaLectura.volumen);\n\nif (nuevoEstado === \"rellenando\" && estadoTanque !== \"rellenando\") {\n    const { tiempo: tiempoInicio, indice: indiceInicio } = detectarInicioAumento(colaLecturas, nuevaLectura.tiempo);\n    inicioAumento = tiempoInicio;\n    flow.set(INICIO_AUMENTO_KEY, inicioAumento);\n    \n    valorFijo = calcularPromedioAnterior(colaLecturas, indiceInicio);\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n    \n    colaLecturas = colaLecturas.slice(0, indiceInicio);\n} else if (nuevoEstado === \"vaciando\" && estadoTanque !== \"vaciando\") {\n    // Iniciar nueva cola al comenzar a vaciar\n    colaLecturas = [];\n    inicioAumento = null;\n    flow.set(INICIO_AUMENTO_KEY, null);\n    valorFijo = 0;\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n}\n\nestadoTanque = nuevoEstado;\nflow.set(ESTADO_TANQUE_KEY, estadoTanque);\n\nif (estadoTanque !== \"rellenando\") {\n    // A√±adir la nueva lectura\n    colaLecturas.push(nuevaLectura);\n    \n    // Mantener solo los √∫ltimos 5 minutos de datos\n    const cincoMinutosAtras = Date.now() - 5 * 60 * 1000;\n    colaLecturas = colaLecturas.filter(lectura => lectura.tiempo >= cincoMinutosAtras);\n}\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\nflow.set(ULTIMO_VOLUMEN_KEY, nuevaLectura.volumen);\n\nreturn { payload: { colaLecturas, estadoTanque, valorFijo } };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1600,
        "wires": [
            [
                "c57c841f2bb28c66",
                "dc31a45942600cc0"
            ]
        ]
    },
    {
        "id": "c57c841f2bb28c66",
        "type": "switch",
        "z": "af01d920764bfaad",
        "name": "Estado del Tanque",
        "property": "payload.estadoTanque",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "vaciando",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "rellenando",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1760,
        "y": 1600,
        "wires": [
            [
                "58cfcaba1634c620"
            ],
            [
                "e67231cd108b7785"
            ]
        ]
    },
    {
        "id": "58cfcaba1634c620",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo de Flujo (Vaciado)",
        "func": "function calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nconst { colaLecturas } = msg.payload;\n\nlet flujo = calcularFlujo(colaLecturas);\n\nreturn { payload: flujo, estadoTanque: \"vaciando\" };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 1580,
        "wires": [
            [
                "9588d27ab190dfc7"
            ]
        ]
    },
    {
        "id": "e67231cd108b7785",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo de Flujo (Rellenado)",
        "func": "const { valorFijo } = msg.payload;\n\nreturn { payload: valorFijo, estadoTanque: \"rellenando\" };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 1620,
        "wires": [
            [
                "9588d27ab190dfc7"
            ]
        ]
    },
    {
        "id": "271bef41b53debda",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Procesamiento Unificado",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction detectarCambioVolumen(ultimoVolumen, nuevoVolumen) {\n    if (nuevoVolumen > ultimoVolumen + 70) return \"rellenando\";\n    if (nuevoVolumen < ultimoVolumen - 5) return \"vaciando\";\n    return \"estable\";\n}\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || msg.payload;\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\nconst nuevoEstado = detectarCambioVolumen(ultimoVolumen, nuevaLectura.volumen);\n\nif (nuevoEstado === \"rellenando\" && estadoTanque !== \"rellenando\") {\n    valorFijo = calcularFlujo(colaLecturas);\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n    colaLecturas = [];\n} else if (nuevoEstado === \"vaciando\" && estadoTanque === \"rellenando\") {\n    colaLecturas = [];\n    valorFijo = 0;\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n}\n\nestadoTanque = nuevoEstado;\nflow.set(ESTADO_TANQUE_KEY, estadoTanque);\n\nif (estadoTanque !== \"rellenando\") {\n    colaLecturas.push(nuevaLectura);\n    if (colaLecturas.length > 60) { // Mantener m√°ximo 5 minutos de datos (asumiendo una lectura por segundo)\n        colaLecturas.shift();\n    }\n}\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\nflow.set(ULTIMO_VOLUMEN_KEY, nuevaLectura.volumen);\n\nlet flujo = estadoTanque === \"rellenando\" ? valorFijo : calcularFlujo(colaLecturas);\n\nreturn { payload: flujo, estadoTanque: estadoTanque };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 2040,
        "wires": [
            [
                "35e7905eec538cc7"
            ]
        ]
    },
    {
        "id": "35e7905eec538cc7",
        "type": "delay",
        "z": "af01d920764bfaad",
        "name": "Rate Limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "2",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 1860,
        "y": 2040,
        "wires": [
            [
                "aac4fd7c3408c33e"
            ]
        ]
    },
    {
        "id": "aac4fd7c3408c33e",
        "type": "ui-gauge",
        "z": "af01d920764bfaad",
        "name": "Flujo COPE 2",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE 2",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2100,
        "y": 2020,
        "wires": []
    },
    {
        "id": "a8961820db081721",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 820,
        "y": 2080,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "883093738e562ce0",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 2200,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "0f5bc489883b64fc",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1110,
        "y": 2080,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "b3e0c433f03736c3",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 2200,
        "wires": [
            [
                "2d3e6fd28baa840e"
            ],
            [],
            [
                "8f399e04394977db"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "30f69581b33ef6c4",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 630,
        "y": 2200,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "8f399e04394977db",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 2220,
        "wires": [
            []
        ]
    },
    {
        "id": "3538e9598dd12e39",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 820,
        "y": 2200,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "2d3e6fd28baa840e",
        "type": "modbus-flex-getter",
        "z": "af01d920764bfaad",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1330,
        "y": 2160,
        "wires": [
            [
                "0f5bc489883b64fc",
                "ed96aa92bdfd1491"
            ],
            []
        ]
    },
    {
        "id": "b5e52bfad7619743",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 800,
        "y": 2120,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "28df7c30ecd22194",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 800,
        "y": 2160,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "ed96aa92bdfd1491",
        "type": "switch",
        "z": "af01d920764bfaad",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1560,
        "y": 2140,
        "wires": [
            [],
            [
                "bad152329d7744da",
                "271bef41b53debda"
            ],
            []
        ]
    },
    {
        "id": "bad152329d7744da",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor num√©rico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1800,
        "y": 2140,
        "wires": [
            [
                "132614d9815855ca",
                "663ced9e2b42770e"
            ]
        ]
    },
    {
        "id": "132614d9815855ca",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1940,
        "y": 2140,
        "wires": [
            []
        ]
    },
    {
        "id": "663ced9e2b42770e",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2090,
        "y": 2140,
        "wires": [
            [
                "5a2796e839e67677"
            ]
        ]
    },
    {
        "id": "5a2796e839e67677",
        "type": "ui-chart",
        "z": "af01d920764bfaad",
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02 2",
        "label": "Volumen FA-02 2",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 2250,
        "y": 2140,
        "wires": [
            []
        ]
    },
    {
        "id": "9a4b4e6afdfa616e",
        "type": "link in",
        "z": "af01d920764bfaad",
        "name": "link in 57",
        "links": [],
        "x": 715,
        "y": 2200,
        "wires": [
            [
                "b3e0c433f03736c3"
            ]
        ]
    },
    {
        "id": "7ff0c466c2d0e921",
        "type": "ui-gauge",
        "z": "af01d920764bfaad",
        "d": true,
        "name": "Flujo COPE 3",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE 3",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2430,
        "y": 2760,
        "wires": []
    },
    {
        "id": "5c360cb8bec661ef",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 460,
        "y": 2560,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "60121aabdcf6d416",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 2680,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "5be5e7d73f25b8ed",
        "type": "change",
        "z": "af01d920764bfaad",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 750,
        "y": 2560,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "dad3247a51f9a23c",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 2680,
        "wires": [
            [
                "7748c79ca3896ebb"
            ],
            [],
            [
                "1100caf710bca0a4"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "3d88a92f0c350b8a",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 270,
        "y": 2680,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "1100caf710bca0a4",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de informaci√≥n\n    node.log(\"Informaci√≥n: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar l√≥gica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones espec√≠ficas\n// seg√∫n el estado del dispositivo (en l√≠nea, fuera de l√≠nea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 2700,
        "wires": [
            []
        ]
    },
    {
        "id": "d59911ca831cbf67",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 460,
        "y": 2680,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "7748c79ca3896ebb",
        "type": "modbus-flex-getter",
        "z": "af01d920764bfaad",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 970,
        "y": 2640,
        "wires": [
            [
                "5be5e7d73f25b8ed",
                "393156469dbc9c1f",
                "f89da0022e5bb30d"
            ],
            []
        ]
    },
    {
        "id": "77d53a224eeca6dc",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 440,
        "y": 2600,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "10f69bc45d1a55e1",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 440,
        "y": 2640,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "7477fbbc14eeaf6c",
        "type": "link in",
        "z": "af01d920764bfaad",
        "name": "link in 58",
        "links": [],
        "x": 355,
        "y": 2680,
        "wires": [
            [
                "dad3247a51f9a23c"
            ]
        ]
    },
    {
        "id": "393156469dbc9c1f",
        "type": "switch",
        "z": "af01d920764bfaad",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1010,
        "y": 2540,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "561c83842c90b3ce",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor num√©rico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 2580,
        "wires": [
            [
                "2da340e8835ea481",
                "b875da297f6f0feb"
            ]
        ]
    },
    {
        "id": "2da340e8835ea481",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1540,
        "y": 2580,
        "wires": [
            []
        ]
    },
    {
        "id": "b875da297f6f0feb",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 2580,
        "wires": [
            [
                "88f2e3516e873435"
            ]
        ]
    },
    {
        "id": "88f2e3516e873435",
        "type": "ui-chart",
        "z": "af01d920764bfaad",
        "d": true,
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02 3",
        "label": "Volumen FA-02 3",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1850,
        "y": 2580,
        "wires": [
            []
        ]
    },
    {
        "id": "f89da0022e5bb30d",
        "type": "debug",
        "z": "af01d920764bfaad",
        "name": "debug 94",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 2780,
        "wires": []
    },
    {
        "id": "dc31a45942600cc0",
        "type": "debug",
        "z": "af01d920764bfaad",
        "name": "debug 95",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1670,
        "y": 1500,
        "wires": []
    },
    {
        "id": "d41434300268b9c4",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Entrada de Datos y Mantenimiento de Cola",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\ncolaLecturas.push(nuevaLectura);\n\n// Mantener solo los √∫ltimos 5 minutos de datos\nconst cincoMinutosAtras = Date.now() - 5 * 60 * 1000;\ncolaLecturas = colaLecturas.filter(lectura => lectura.tiempo >= cincoMinutosAtras);\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\n\nreturn { payload: colaLecturas };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 2680,
        "wires": [
            [
                "d29d7448081c9735"
            ]
        ]
    },
    {
        "id": "d29d7448081c9735",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Detecci√≥n de Estado del Tanque",
        "func": "const ESTADO_TANQUE_KEY = \"estadoTanque\";\nlet estadoAnterior = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\n\nconst colaLecturas = msg.payload;\nif (colaLecturas.length < 2) return null;\n\nconst ultimaLectura = colaLecturas[colaLecturas.length - 1];\nconst penultimaLectura = colaLecturas[colaLecturas.length - 2];\n\nlet nuevoEstado;\nif (ultimaLectura.volumen > penultimaLectura.volumen + 70) {\n    nuevoEstado = \"rellenando\";\n} else if (ultimaLectura.volumen < penultimaLectura.volumen - 5) {\n    nuevoEstado = \"vaciando\";\n} else {\n    nuevoEstado = \"estable\";\n}\n\nflow.set(ESTADO_TANQUE_KEY, nuevoEstado);\n\nreturn { payload: { colaLecturas, estadoAnterior, nuevoEstado } };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 2720,
        "wires": [
            [
                "44a534f6558a08d6"
            ]
        ]
    },
    {
        "id": "44a534f6558a08d6",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Manejo de Transiciones de Estado",
        "func": "const { colaLecturas, estadoAnterior, nuevoEstado } = msg.payload;\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction encontrarInicioAumento(cola) {\n    for (let i = cola.length - 1; i > 0; i--) {\n        if (cola[i].volumen <= cola[i-1].volumen) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nfunction calcularPromedioFlujo(lecturas) {\n    if (lecturas.length < 2) return 0;\n    let sumaFlujo = 0;\n    for (let i = 1; i < lecturas.length; i++) {\n        const tiempoDiff = (lecturas[i].tiempo - lecturas[i-1].tiempo) / 1000;\n        const volumenDiff = lecturas[i-1].volumen - lecturas[i].volumen;\n        if (tiempoDiff > 0) {\n            sumaFlujo += (volumenDiff / tiempoDiff) * 3600;\n        }\n    }\n    return sumaFlujo / (lecturas.length - 1);\n}\n\nif (nuevoEstado === \"rellenando\" && estadoAnterior !== \"rellenando\") {\n    const inicioAumento = encontrarInicioAumento(colaLecturas);\n    const promedioFlujo = calcularPromedioFlujo(colaLecturas.slice(0, inicioAumento));\n    flow.set(VALOR_FIJO_KEY, promedioFlujo);\n    colaLecturas.splice(0, inicioAumento);\n} else if (nuevoEstado === \"vaciando\" && estadoAnterior === \"rellenando\") {\n    colaLecturas.splice(0, colaLecturas.length - 1);\n    flow.set(VALOR_FIJO_KEY, null);\n}\n\nreturn { payload: { colaLecturas, estado: nuevoEstado } };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 2760,
        "wires": [
            [
                "99d30aaa2831acc7"
            ]
        ]
    },
    {
        "id": "99d30aaa2831acc7",
        "type": "switch",
        "z": "af01d920764bfaad",
        "name": "Estado del Tanque",
        "property": "payload.estado",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "vaciando",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "rellenando",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "estable",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1690,
        "y": 2760,
        "wires": [
            [
                "94cb9a7b7d11bc11"
            ],
            [
                "0f04ef985c1c5ecd"
            ],
            [
                "c010b6710df4b45e"
            ]
        ]
    },
    {
        "id": "94cb9a7b7d11bc11",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo Flujo (Vaciando)",
        "func": "const colaLecturas = msg.payload.colaLecturas;\nif (colaLecturas.length < 2) return { payload: 0 };\n\nconst primeraLectura = colaLecturas[0];\nconst ultimaLectura = colaLecturas[colaLecturas.length - 1];\n\nconst tiempoTranscurrido = (ultimaLectura.tiempo - primeraLectura.tiempo) / 1000;\nconst cambioVolumen = primeraLectura.volumen - ultimaLectura.volumen;\n\nif (tiempoTranscurrido > 0) {\n    const flujo = (cambioVolumen / tiempoTranscurrido) * 3600;\n    return { payload: Math.round(flujo) };\n}\n\nreturn { payload: 0 };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1940,
        "y": 2720,
        "wires": [
            [
                "ecc96c8acaffeafb"
            ]
        ]
    },
    {
        "id": "0f04ef985c1c5ecd",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo Flujo (Rellenando)",
        "func": "const valorFijo = flow.get(\"valorFijo\");\nreturn { payload: valorFijo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1950,
        "y": 2760,
        "wires": [
            [
                "ecc96c8acaffeafb"
            ]
        ]
    },
    {
        "id": "c010b6710df4b45e",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo Flujo (Estable)",
        "func": "const colaLecturas = msg.payload.colaLecturas;\nif (colaLecturas.length < 2) return { payload: 0 };\n\nconst primeraLectura = colaLecturas[0];\nconst ultimaLectura = colaLecturas[colaLecturas.length - 1];\n\nconst tiempoTranscurrido = (ultimaLectura.tiempo - primeraLectura.tiempo) / 1000;\nconst cambioVolumen = primeraLectura.volumen - ultimaLectura.volumen;\n\nif (tiempoTranscurrido > 0) {\n    const flujo = (cambioVolumen / tiempoTranscurrido) * 3600;\n    return { payload: Math.round(flujo) };\n}\n\nreturn { payload: 0 };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1940,
        "y": 2800,
        "wires": [
            [
                "ecc96c8acaffeafb"
            ]
        ]
    },
    {
        "id": "ecc96c8acaffeafb",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Salida de Datos",
        "func": "return { payload: msg.payload, topic: msg.payload.estado };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2240,
        "y": 2760,
        "wires": [
            [
                "7ff0c466c2d0e921"
            ]
        ]
    },
    {
        "id": "89be79f4a9086932",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Simulador Disminuci√≥n",
        "func": "const RANGO_MIN = 4000;\nconst RANGO_MAX = 20000;\nconst CAPACIDAD_TOTAL = 40000; // Litros\nconst TASA_VACIADO = 5000; // Litros por hora\n\nlet nivelActual = context.get('nivelActual') || CAPACIDAD_TOTAL;\nlet ultimaActualizacion = context.get('ultimaActualizacion') || Date.now();\n\nfunction actualizarNivel() {\n    const ahora = Date.now();\n    const tiempoTranscurrido = (ahora - ultimaActualizacion) / 3600000; // Convertir a horas\n    \n    // Calcular el nuevo nivel\n    const cambioNivel = TASA_VACIADO * tiempoTranscurrido;\n    nivelActual -= cambioNivel;\n    \n    // Asegurar que el nivel est√© dentro del rango\n    if (nivelActual < 0) {\n        nivelActual = 0;\n    }\n    \n    // Convertir el nivel actual a la escala de 4000-20000\n    const nivelEscalado = RANGO_MIN + (nivelActual / CAPACIDAD_TOTAL) * (RANGO_MAX - RANGO_MIN);\n    \n    // Guardar el estado actual\n    context.set('nivelActual', nivelActual);\n    context.set('ultimaActualizacion', ahora);\n    \n    return Math.round(nivelEscalado);\n}\n\nreturn { payload: actualizarNivel() };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 2900,
        "wires": [
            [
                "561c83842c90b3ce",
                "d41434300268b9c4"
            ]
        ]
    },
    {
        "id": "71b999c3a88f5331",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Simulador Aumento",
        "func": "const RANGO_MIN = 4000;\nconst RANGO_MAX = 20000;\nconst CAPACIDAD_TOTAL = 40000; // Litros\nconst TASA_LLENADO = 10000; // Litros por hora\n\nlet nivelActual = context.get('nivelActual') || 0;\nlet ultimaActualizacion = context.get('ultimaActualizacion') || Date.now();\n\nfunction actualizarNivel() {\n    const ahora = Date.now();\n    const tiempoTranscurrido = (ahora - ultimaActualizacion) / 3600000; // Convertir a horas\n    \n    // Calcular el nuevo nivel\n    const cambioNivel = TASA_LLENADO * tiempoTranscurrido;\n    nivelActual += cambioNivel;\n    \n    // Asegurar que el nivel est√© dentro del rango\n    if (nivelActual > CAPACIDAD_TOTAL) {\n        nivelActual = CAPACIDAD_TOTAL;\n    }\n    \n    // Convertir el nivel actual a la escala de 4000-20000\n    const nivelEscalado = RANGO_MIN + (nivelActual / CAPACIDAD_TOTAL) * (RANGO_MAX - RANGO_MIN);\n    \n    // Guardar el estado actual\n    context.set('nivelActual', nivelActual);\n    context.set('ultimaActualizacion', ahora);\n    \n    return Math.round(nivelEscalado);\n}\n\nreturn { payload: actualizarNivel() };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 2960,
        "wires": [
            [
                "d41434300268b9c4",
                "561c83842c90b3ce"
            ]
        ]
    },
    {
        "id": "8acbf5d1fc6bcaf7",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "Activar Disminuci√≥n",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "disminucion",
        "payload": "",
        "payloadType": "date",
        "x": 890,
        "y": 2900,
        "wires": [
            [
                "89be79f4a9086932"
            ]
        ]
    },
    {
        "id": "1c73072a8e97ee42",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "Activar Aumento",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "aumento",
        "payload": "",
        "payloadType": "date",
        "x": 880,
        "y": 2960,
        "wires": [
            [
                "71b999c3a88f5331"
            ]
        ]
    },
    {
        "id": "517168df1b107e11",
        "type": "ui-gauge",
        "z": "af01d920764bfaad",
        "name": "Flujo COPE 3",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE 3",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2200,
        "y": 3260,
        "wires": []
    },
    {
        "id": "023c4c14a50c996f",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "calc_vol",
        "func": "function calcVol(msg) {\n    const valorCrudo = msg.payload;\n    const valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\n    msg.payload = Math.round(valorLitros);\n    return msg;\n}\n\nreturn calcVol(msg);",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 3080,
        "wires": [
            [
                "5c308a1de314faa0",
                "a50ebdc96a082f3e"
            ]
        ]
    },
    {
        "id": "5c308a1de314faa0",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 3080,
        "wires": [
            []
        ]
    },
    {
        "id": "a50ebdc96a082f3e",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 3080,
        "wires": [
            [
                "d573efa5c12c9c04"
            ]
        ]
    },
    {
        "id": "d573efa5c12c9c04",
        "type": "ui-chart",
        "z": "af01d920764bfaad",
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02 3",
        "label": "Volumen FA-02 3",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1620,
        "y": 3080,
        "wires": [
            []
        ]
    },
    {
        "id": "bd943fe77a4f96ec",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Entrada de Datos y Mantenimiento de Cola",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\ncolaLecturas.push(nuevaLectura);\n\n// Mantener solo los √∫ltimos 5 minutos de datos\nconst cincoMinutosAtras = Date.now() - 5 * 60 * 1000;\ncolaLecturas = colaLecturas.filter(lectura => lectura.tiempo >= cincoMinutosAtras);\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\n\nreturn { payload: colaLecturas };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 3180,
        "wires": [
            [
                "69b116a794138344"
            ]
        ]
    },
    {
        "id": "69b116a794138344",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Detecci√≥n de Estado del Tanque",
        "func": "const ESTADO_TANQUE_KEY = \"estadoTanque\";\nlet estadoAnterior = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\n\nconst colaLecturas = msg.payload;\nif (colaLecturas.length < 2) return null;\n\nconst ultimaLectura = colaLecturas[colaLecturas.length - 1];\nconst penultimaLectura = colaLecturas[colaLecturas.length - 2];\n\nlet nuevoEstado;\nif (ultimaLectura.volumen > penultimaLectura.volumen + 70) {\n    nuevoEstado = \"rellenando\";\n} else if (ultimaLectura.volumen < penultimaLectura.volumen - 5) {\n    nuevoEstado = \"vaciando\";\n} else {\n    nuevoEstado = \"estable\";\n}\n\nflow.set(ESTADO_TANQUE_KEY, nuevoEstado);\n\nreturn { payload: { colaLecturas, estadoAnterior, nuevoEstado } };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 3220,
        "wires": [
            [
                "7a68b022d50a6c0c"
            ]
        ]
    },
    {
        "id": "7a68b022d50a6c0c",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Manejo de Transiciones de Estado",
        "func": "const { colaLecturas, estadoAnterior, nuevoEstado } = msg.payload;\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction encontrarInicioAumento(cola) {\n    for (let i = cola.length - 1; i > 0; i--) {\n        if (cola[i].volumen <= cola[i-1].volumen) {\n            return i;\n        }\n    }\n    return 0;\n}\n\nfunction calcularPromedioFlujo(lecturas) {\n    if (lecturas.length < 2) return 0;\n    let sumaFlujo = 0;\n    for (let i = 1; i < lecturas.length; i++) {\n        const tiempoDiff = (lecturas[i].tiempo - lecturas[i-1].tiempo) / 1000;\n        const volumenDiff = lecturas[i-1].volumen - lecturas[i].volumen;\n        if (tiempoDiff > 0) {\n            sumaFlujo += (volumenDiff / tiempoDiff) * 3600;\n        }\n    }\n    return sumaFlujo / (lecturas.length - 1);\n}\n\nif (nuevoEstado === \"rellenando\" && estadoAnterior !== \"rellenando\") {\n    const inicioAumento = encontrarInicioAumento(colaLecturas);\n    const promedioFlujo = calcularPromedioFlujo(colaLecturas.slice(0, inicioAumento));\n    flow.set(VALOR_FIJO_KEY, promedioFlujo);\n    colaLecturas.splice(0, inicioAumento);\n} else if (nuevoEstado === \"vaciando\" && estadoAnterior === \"rellenando\") {\n    colaLecturas.splice(0, colaLecturas.length - 1);\n    flow.set(VALOR_FIJO_KEY, null);\n}\n\nreturn { payload: { colaLecturas, estado: nuevoEstado } };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 3260,
        "wires": [
            [
                "a22b057d9cef8bba"
            ]
        ]
    },
    {
        "id": "a22b057d9cef8bba",
        "type": "switch",
        "z": "af01d920764bfaad",
        "name": "Estado del Tanque",
        "property": "payload.estado",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "vaciando",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "rellenando",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "estable",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1460,
        "y": 3260,
        "wires": [
            [
                "4d81bad3c5b6ef04"
            ],
            [
                "0fe38783ee3564a3"
            ],
            [
                "d38086480cc62df1"
            ]
        ]
    },
    {
        "id": "4d81bad3c5b6ef04",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo Flujo (Vaciando)",
        "func": "const colaLecturas = msg.payload.colaLecturas;\nif (colaLecturas.length < 2) return { payload: 0 };\n\nconst primeraLectura = colaLecturas[0];\nconst ultimaLectura = colaLecturas[colaLecturas.length - 1];\n\nconst tiempoTranscurrido = (ultimaLectura.tiempo - primeraLectura.tiempo) / 1000;\nconst cambioVolumen = primeraLectura.volumen - ultimaLectura.volumen;\n\nif (tiempoTranscurrido > 0) {\n    const flujo = (cambioVolumen / tiempoTranscurrido) * 3600;\n    return { payload: Math.round(flujo) };\n}\n\nreturn { payload: 0 };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1710,
        "y": 3220,
        "wires": [
            [
                "822941440435831f"
            ]
        ]
    },
    {
        "id": "0fe38783ee3564a3",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo Flujo (Rellenando)",
        "func": "const valorFijo = flow.get(\"valorFijo\");\nreturn { payload: valorFijo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1720,
        "y": 3260,
        "wires": [
            [
                "822941440435831f"
            ]
        ]
    },
    {
        "id": "d38086480cc62df1",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "C√°lculo Flujo (Estable)",
        "func": "const colaLecturas = msg.payload.colaLecturas;\nif (colaLecturas.length < 2) return { payload: 0 };\n\nconst primeraLectura = colaLecturas[0];\nconst ultimaLectura = colaLecturas[colaLecturas.length - 1];\n\nconst tiempoTranscurrido = (ultimaLectura.tiempo - primeraLectura.tiempo) / 1000;\nconst cambioVolumen = primeraLectura.volumen - ultimaLectura.volumen;\n\nif (tiempoTranscurrido > 0) {\n    const flujo = (cambioVolumen / tiempoTranscurrido) * 3600;\n    return { payload: Math.round(flujo) };\n}\n\nreturn { payload: 0 };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1710,
        "y": 3300,
        "wires": [
            [
                "822941440435831f"
            ]
        ]
    },
    {
        "id": "822941440435831f",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Salida de Datos",
        "func": "return { payload: msg.payload, topic: msg.payload.estado };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 3260,
        "wires": [
            [
                "517168df1b107e11"
            ]
        ]
    },
    {
        "id": "947d9fd1ed9fad23",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Simulador Disminuci√≥n",
        "func": "const RANGO_MIN = 4000;\nconst RANGO_MAX = 20000;\nconst CAPACIDAD_TOTAL = 40000; // Litros\nconst TASA_VACIADO = 5000; // Litros por hora\n\nlet nivelActual = context.get('nivelActual') || CAPACIDAD_TOTAL;\nlet ultimaActualizacion = context.get('ultimaActualizacion') || Date.now();\n\nfunction actualizarNivel() {\n    const ahora = Date.now();\n    const tiempoTranscurrido = (ahora - ultimaActualizacion) / 3600000; // Convertir a horas\n    \n    // Calcular el nuevo nivel\n    const cambioNivel = TASA_VACIADO * tiempoTranscurrido;\n    nivelActual -= cambioNivel;\n    \n    // Asegurar que el nivel est√© dentro del rango\n    if (nivelActual < 0) {\n        nivelActual = 0;\n    }\n    \n    // Convertir el nivel actual a la escala de 4000-20000\n    const nivelEscalado = RANGO_MIN + (nivelActual / CAPACIDAD_TOTAL) * (RANGO_MAX - RANGO_MIN);\n    \n    // Guardar el estado actual\n    context.set('nivelActual', nivelActual);\n    context.set('ultimaActualizacion', ahora);\n    \n    return Math.round(nivelEscalado);\n}\n\nreturn { payload: actualizarNivel() };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 3400,
        "wires": [
            [
                "023c4c14a50c996f",
                "bd943fe77a4f96ec"
            ]
        ]
    },
    {
        "id": "94bca84f165a8fc1",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Simulador Aumento",
        "func": "const RANGO_MIN = 4000;\nconst RANGO_MAX = 20000;\nconst CAPACIDAD_TOTAL = 40000; // Litros\nconst TASA_LLENADO = 10000; // Litros por hora\n\nlet nivelActual = context.get('nivelActual') || 0;\nlet ultimaActualizacion = context.get('ultimaActualizacion') || Date.now();\n\nfunction actualizarNivel() {\n    const ahora = Date.now();\n    const tiempoTranscurrido = (ahora - ultimaActualizacion) / 3600000; // Convertir a horas\n    \n    // Calcular el nuevo nivel\n    const cambioNivel = TASA_LLENADO * tiempoTranscurrido;\n    nivelActual += cambioNivel;\n    \n    // Asegurar que el nivel est√© dentro del rango\n    if (nivelActual > CAPACIDAD_TOTAL) {\n        nivelActual = CAPACIDAD_TOTAL;\n    }\n    \n    // Convertir el nivel actual a la escala de 4000-20000\n    const nivelEscalado = RANGO_MIN + (nivelActual / CAPACIDAD_TOTAL) * (RANGO_MAX - RANGO_MIN);\n    \n    // Guardar el estado actual\n    context.set('nivelActual', nivelActual);\n    context.set('ultimaActualizacion', ahora);\n    \n    return Math.round(nivelEscalado);\n}\n\nreturn { payload: actualizarNivel() };",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 3460,
        "wires": [
            [
                "bd943fe77a4f96ec",
                "023c4c14a50c996f"
            ]
        ]
    },
    {
        "id": "1bbeb70f8cf39033",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "Activar Disminuci√≥n",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "disminucion",
        "payload": "",
        "payloadType": "date",
        "x": 660,
        "y": 3400,
        "wires": [
            [
                "947d9fd1ed9fad23"
            ]
        ]
    },
    {
        "id": "bc0bcf14fe2d54f7",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "Activar Aumento",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "aumento",
        "payload": "",
        "payloadType": "date",
        "x": 650,
        "y": 3460,
        "wires": [
            [
                "94bca84f165a8fc1"
            ]
        ]
    },
    {
        "id": "8b14a8f2a51b714a",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "Procesamiento Unificado",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction detectarCambioVolumen(ultimoVolumen, nuevoVolumen) {\n    if (nuevoVolumen > ultimoVolumen + 70) return \"rellenando\";\n    if (nuevoVolumen < ultimoVolumen - 5) return \"vaciando\";\n    return \"estable\";\n}\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || msg.payload;\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\nconst nuevoEstado = detectarCambioVolumen(ultimoVolumen, nuevaLectura.volumen);\n\nif (nuevoEstado === \"rellenando\" && estadoTanque !== \"rellenando\") {\n    valorFijo = calcularFlujo(colaLecturas);\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n    colaLecturas = [];\n} else if (nuevoEstado === \"vaciando\" && estadoTanque === \"rellenando\") {\n    colaLecturas = [];\n    valorFijo = 0;\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n}\n\nestadoTanque = nuevoEstado;\nflow.set(ESTADO_TANQUE_KEY, estadoTanque);\n\nif (estadoTanque !== \"rellenando\") {\n    colaLecturas.push(nuevaLectura);\n    if (colaLecturas.length > 60) { // Mantener m√°ximo 5 minutos de datos (asumiendo una lectura por segundo)\n        colaLecturas.shift();\n    }\n}\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\nflow.set(ULTIMO_VOLUMEN_KEY, nuevaLectura.volumen);\n\nlet flujo = estadoTanque === \"rellenando\" ? valorFijo : calcularFlujo(colaLecturas);\n\nreturn { payload: flujo, estadoTanque: estadoTanque };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 200,
        "wires": [
            [
                "bd6efa7cd8fca6ee"
            ]
        ]
    },
    {
        "id": "bd6efa7cd8fca6ee",
        "type": "delay",
        "z": "af01d920764bfaad",
        "name": "Rate Limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "5",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 2210,
        "y": 200,
        "wires": [
            [
                "2ca13e8e5dd760ea"
            ]
        ]
    },
    {
        "id": "2ca13e8e5dd760ea",
        "type": "ui_gauge",
        "z": "af01d920764bfaad",
        "name": "Flujo COPE",
        "group": "panel_principal",
        "order": 0,
        "width": 0,
        "height": 0,
        "gtype": "gage",
        "title": "Flujo COPE",
        "label": "L/h",
        "format": "{{value}}",
        "min": 0,
        "max": "10000",
        "colors": [
            "#00b500",
            "#e6e600",
            "#ca3838"
        ],
        "seg1": "",
        "seg2": "",
        "x": 2430,
        "y": 200,
        "wires": []
    },
    {
        "id": "f88328edacbc5f15",
        "type": "inject",
        "z": "af01d920764bfaad",
        "name": "Simulaci√≥n de entrada de volumen",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "num",
        "x": 1670,
        "y": 200,
        "wires": [
            [
                "8b14a8f2a51b714a"
            ]
        ]
    },
    {
        "id": "6e78145f73fc1d42",
        "type": "function",
        "z": "af01d920764bfaad",
        "name": "State Detection",
        "func": "// Obtener la cola de lecturas del mensaje\nlet cola = msg.payload;\n\n// Obtener las √∫ltimas 10 lecturas de volumen\nlet lecturasVolumen = cola.map(registro => registro.volumen);\nlet numLecturas = lecturasVolumen.length;\n\n// Inicializar contadores\nlet aumentos = 0;\nlet disminuciones = 0;\nlet estables = 0;\n\n// Analizar las lecturas para detectar el estado\nfor (let i = Math.max(numLecturas - 10, 1); i < numLecturas; i++) {\n    let diferencia = lecturasVolumen[i] - lecturasVolumen[i - 1];\n    if (diferencia > 0) {\n        aumentos++;\n        disminuciones = 0;\n        estables = 0;\n    } else if (diferencia < 0) {\n        disminuciones++;\n        aumentos = 0;\n        estables = 0;\n    } else {\n        estables++;\n        aumentos = 0;\n        disminuciones = 0;\n    }\n}\n\n// Determinar el estado\nlet estado = flow.get(\"estado\") || \"Desconocido\";\n\nif (aumentos >= 4) {\n    estado = \"Relleno\";\n} else if (disminuciones >= 4) {\n    estado = \"Alimentaci√≥n\";\n} else if (estables >= 10 && Math.abs(lecturasVolumen[numLecturas - 1] - lecturasVolumen[numLecturas - 2]) <= 20) {\n    estado = \"Estable\";\n}\n\n// Guardar el estado en el contexto\nflow.set(\"estado\", estado);\n\n// A√±adir el estado al mensaje\nmsg.estado = estado;\n\n// Pasar el mensaje al siguiente nodo\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1840,
        "y": 500,
        "wires": [
            []
        ]
    }
]