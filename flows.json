[
    {
        "id": "190ed3e96d0709a5",
        "type": "tab",
        "label": "ADC2",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "4f1c58c90aef2801",
        "type": "tab",
        "label": "ADC_8CH",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "0a1446a2506c6a05",
        "type": "tab",
        "label": "calculo flujo optimizado",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "0eebc14e6b9c0fb5",
        "type": "tab",
        "label": "Flujo Optimizado",
        "disabled": true,
        "info": ""
    },
    {
        "id": "663b1dbab4a22bc2",
        "type": "tab",
        "label": "FIVERR",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "cf449ce1322fd8eb",
        "type": "tab",
        "label": "T. Principal RTU",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1b6aa974e2ca303d",
        "type": "subflow",
        "name": "Calcular Volumen y Enviar",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 60,
                "wires": [
                    {
                        "id": "bc34e8077dafa34c"
                    }
                ]
            }
        ],
        "out": [],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "7ac8f4b3a29c864f",
        "type": "mqtt-broker",
        "name": "MN-1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "bb61bb0c49cb82b4",
        "type": "mqtt-broker",
        "name": "MN-9",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "aeb8c7546d28ce5c",
        "type": "mqtt-broker",
        "name": "MN-7",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "661d09df777a5259",
        "type": "modbus-client",
        "name": "pruebas",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.75",
        "tcpPort": "502",
        "tcpType": "DEFAULT",
        "serialPort": "/dev/ttyUSB0",
        "serialType": "RTU",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": 1,
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "3f690bb5a526a246",
        "type": "ui-group",
        "name": "Tablero Alimentación Sistema",
        "page": "53bbd3554f5781e9",
        "width": "12",
        "height": "2",
        "order": 3,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "a1b3d7fc83d5c6f6",
        "type": "Stackhero-InfluxDB-v2-Server",
        "name": "",
        "host": "influxdb2",
        "port": "8086",
        "tls": false
    },
    {
        "id": "53bbd3554f5781e9",
        "type": "ui-page",
        "name": "Tablero principal",
        "ui": "bc1023506614f084",
        "path": "/pageN",
        "icon": "home",
        "layout": "grid",
        "theme": "60ac3cbdefc9f2e1",
        "order": 1,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "bc1023506614f084",
        "type": "ui-base",
        "name": "Valores sensores",
        "path": "/dashboard",
        "includeClientData": true,
        "acceptsClientConfig": [
            "ui-notification",
            "ui-control"
        ],
        "showPathInSidebar": false,
        "navigationStyle": "default"
    },
    {
        "id": "60ac3cbdefc9f2e1",
        "type": "ui-theme",
        "name": "Default Theme",
        "colors": {
            "surface": "#ffffff",
            "primary": "#0094ce",
            "bgPage": "#eeeeee",
            "groupBg": "#ffffff",
            "groupOutline": "#cccccc"
        },
        "sizes": {
            "pagePadding": "12px",
            "groupGap": "12px",
            "groupBorderRadius": "4px",
            "widgetGap": "14px"
        }
    },
    {
        "id": "90c50477d9bdd042",
        "type": "ui-group",
        "name": "Tablero HCD",
        "page": "53bbd3554f5781e9",
        "width": "12",
        "height": "1",
        "order": 4,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "74e31200f882aea8",
        "type": "mqtt-broker",
        "name": "MN-4",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "714e095421e2277c",
        "type": "mqtt-broker",
        "name": "MN-06A",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "3e658c694e790b36",
        "type": "mqtt-broker",
        "name": "MN-6B",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "7010d93871a46530",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MF-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "0274315f4b847684",
        "type": "modbus-client",
        "name": "VOLISON_4CH",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.202",
        "tcpPort": "502",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB1",
        "serialType": "RTU",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "1514c5b7f877eca4",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MN-2.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "32c32aed21b2158b",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MF-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "e11805043013252c",
        "type": "mqtt-broker",
        "name": "mqtt_tb_MP-1.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "656e301905d6c960",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-2.1",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "2949ed73ecfc0cf4",
        "type": "ui-group",
        "name": "Calentador de carga",
        "page": "53bbd3554f5781e9",
        "width": "3",
        "height": "1",
        "order": 1,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "ef01f57616a5ac26",
        "type": "mqtt-broker",
        "name": "mqtt_tb_ST-2.2",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "27e2c5634b9f1073",
        "type": "modbus-client",
        "name": "Waveshare Modbus RTU",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": true,
        "tcpHost": "192.168.1.201",
        "tcpPort": "503",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": "9600",
        "serialDatabits": "8",
        "serialStopbits": "1",
        "serialParity": "none",
        "serialConnectionDelay": "100",
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "1",
        "commandDelay": "1",
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "f344d91a44765e3a",
        "type": "mqtt-broker",
        "name": "flujocope",
        "broker": "mqtt.thingsboard.cloud",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "bc34e8077dafa34c",
        "type": "function",
        "z": "1b6aa974e2ca303d",
        "name": "Calcular Volumen",
        "func": "const sensorConfig = {\n    'read_ADC2_AI1': { maxLitros: 19000, equipo_id: 'FA-09', sensor_id: 'MN-9', mqttBroker: 'bb61bb0c49cb82b4' },\n    'read_ADC2_AI2': { maxLitros: 115500, equipo_id: 'FA-01', sensor_id: 'MN-1', mqttBroker: '7ac8f4b3a29c864f' },\n    'read_ADC2_AI3': { maxLitros: 50000, equipo_id: 'FA-XX', sensor_id: 'MN-XX', mqttBroker: 'mqttBrokerID' },\n    'read_ADC2_AI4': { maxLitros: 30000, equipo_id: 'FA-YY', sensor_id: 'MN-YY', mqttBroker: 'mqttBrokerID' }\n};\n\nconst config = sensorConfig[msg.topic];\nconst valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * config.maxLitros;\nmsg.payload = Math.round(valorLitros);\nmsg.equipo_id = config.equipo_id;\nmsg.sensor_id = config.sensor_id;\nmsg.mqttBroker = config.mqttBroker;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 60,
        "wires": [
            [
                "5f1828bf7e42131a",
                "ab4c022dca8a290b",
                "b493823a86913ab5"
            ]
        ]
    },
    {
        "id": "5f1828bf7e42131a",
        "type": "mqtt out",
        "z": "1b6aa974e2ca303d",
        "name": "Enviar a MQTT",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "broker": "",
        "x": 480,
        "y": 40,
        "wires": []
    },
    {
        "id": "ab4c022dca8a290b",
        "type": "function",
        "z": "1b6aa974e2ca303d",
        "name": "Formatear para UI",
        "func": "msg.payload = msg.payload;\nmsg.topic = `Nivel ${msg.equipo_id}`;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 80,
        "wires": [
            [
                "36a9c45880b69202"
            ]
        ]
    },
    {
        "id": "36a9c45880b69202",
        "type": "ui_gauge",
        "z": "1b6aa974e2ca303d",
        "name": "Gauge de Volumen",
        "group": "3f690bb5a526a246",
        "order": 1,
        "width": "6",
        "height": "4",
        "gtype": "gage",
        "title": "{{msg.topic}}",
        "label": "Litros",
        "format": "{{value}}",
        "min": 0,
        "max": "100000",
        "colors": [
            "#00b500",
            "#e6e600",
            "#ca3838"
        ],
        "seg1": "",
        "seg2": "",
        "diff": false,
        "className": "",
        "x": 670,
        "y": 80,
        "wires": []
    },
    {
        "id": "b493823a86913ab5",
        "type": "function",
        "z": "1b6aa974e2ca303d",
        "name": "Enviar a InfluxDB",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: msg.sensor_id,\n                equipo_id: msg.equipo_id,\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 120,
        "wires": [
            [
                "ec9823e16410f948"
            ]
        ]
    },
    {
        "id": "ec9823e16410f948",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "1b6aa974e2ca303d",
        "server": "a1b3d7fc83d5c6f6",
        "name": "InfluxDB",
        "x": 670,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "0c9c4c6ccd5f1680",
        "type": "change",
        "z": "190ed3e96d0709a5",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 800,
        "y": 520,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "a1d380aff2236a21",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic === \"\") || (msg.topic === null) || (msg.topic === undefined)) {\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Topic missing\" });\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current > 0) && (current % resendinterval === 0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg !== undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state === 1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\", []);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i = queue.length - 1; i >= 0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i, 1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\", queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length > 0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0, 1);\n        context.set(\"queue\", queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return [newmsg, null, null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n\n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 700,
        "wires": [
            [
                "935f6caa0c13c143"
            ],
            [],
            [
                "55b26ddfc0cc83ba",
                "9f254561809fe947"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "55b26ddfc0cc83ba",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 780,
        "wires": [
            [
                "2f6892ae26582cc0"
            ]
        ]
    },
    {
        "id": "5c1e21e0692f309f",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 520,
        "y": 780,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "69b686e91740cea5",
        "type": "switch",
        "z": "190ed3e96d0709a5",
        "name": "ADC2 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC2_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI4",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1180,
        "y": 680,
        "wires": [
            [
                "58303efc8fb8844e",
                "358a6d7f67ffce8f"
            ],
            [
                "577bce23d5b23116"
            ],
            [
                "73e1e81e7546e4fb"
            ],
            []
        ]
    },
    {
        "id": "75e2840ee8295271",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 700,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "d24d58116973bc71",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 740,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "577bce23d5b23116",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "calc_vol_FA-01",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (115500 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 560,
        "wires": [
            [
                "168aaf88f24c3fe4",
                "b4188b3a422f8bef",
                "e405700295bd27f7",
                "fcbfd2b58ba9ac83",
                "a77fa9701c726221"
            ],
            []
        ]
    },
    {
        "id": "50d885b438d788be",
        "type": "mqtt out",
        "z": "190ed3e96d0709a5",
        "name": "mqtt_tb_MN-1",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "7ac8f4b3a29c864f",
        "x": 1780,
        "y": 580,
        "wires": []
    },
    {
        "id": "168aaf88f24c3fe4",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 580,
        "wires": [
            [
                "50d885b438d788be"
            ]
        ]
    },
    {
        "id": "b4188b3a422f8bef",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 520,
        "wires": [
            [
                "55044db629aca6f4"
            ]
        ]
    },
    {
        "id": "e405700295bd27f7",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "vol_FA-01",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 560,
        "wires": []
    },
    {
        "id": "358a6d7f67ffce8f",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "calc_vol_FA-09",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (19000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 660,
        "wires": [
            [
                "c1ca46f6bb75b7dd",
                "83a76faa5a6226ef",
                "1765a68bea6d7b05",
                "d250c11d6dec42a9"
            ],
            []
        ]
    },
    {
        "id": "e5568dbdb4388bd7",
        "type": "mqtt out",
        "z": "190ed3e96d0709a5",
        "name": "mqtt_tb_MN-9",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "bb61bb0c49cb82b4",
        "x": 1780,
        "y": 680,
        "wires": []
    },
    {
        "id": "c1ca46f6bb75b7dd",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 680,
        "wires": [
            [
                "e5568dbdb4388bd7"
            ]
        ]
    },
    {
        "id": "83a76faa5a6226ef",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 640,
        "wires": [
            [
                "409147dccbfefd7e"
            ]
        ]
    },
    {
        "id": "1765a68bea6d7b05",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "vol_FA-09",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 660,
        "wires": []
    },
    {
        "id": "73e1e81e7546e4fb",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "calc_vol_FA-07",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (200000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 780,
        "wires": [
            [
                "1925a962bbeb0bdd",
                "ab6e924ec584b66b",
                "72632dd37f42d210",
                "d68d9ad9e6ba918a"
            ],
            []
        ]
    },
    {
        "id": "c22c16254362436d",
        "type": "mqtt out",
        "z": "190ed3e96d0709a5",
        "name": "mqtt_tb_MN-7",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "aeb8c7546d28ce5c",
        "x": 1780,
        "y": 780,
        "wires": []
    },
    {
        "id": "1925a962bbeb0bdd",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 780,
        "wires": [
            [
                "c22c16254362436d"
            ]
        ]
    },
    {
        "id": "ab6e924ec584b66b",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 740,
        "wires": [
            [
                "ad4fc4580773a583"
            ]
        ]
    },
    {
        "id": "72632dd37f42d210",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "vol_FA-07",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1960,
        "y": 760,
        "wires": []
    },
    {
        "id": "935f6caa0c13c143",
        "type": "modbus-flex-getter",
        "z": "190ed3e96d0709a5",
        "name": "ADC2",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": false,
        "logIOActivities": false,
        "server": "661d09df777a5259",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 910,
        "y": 660,
        "wires": [
            [
                "0c9c4c6ccd5f1680",
                "69b686e91740cea5"
            ],
            []
        ]
    },
    {
        "id": "55044db629aca6f4",
        "type": "ui-chart",
        "z": "190ed3e96d0709a5",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-01",
        "label": "Volumen FA-01",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "105000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1800,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "409147dccbfefd7e",
        "type": "ui-chart",
        "z": "190ed3e96d0709a5",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-09",
        "label": "Volumen FA-09",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "20000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1800,
        "y": 640,
        "wires": [
            []
        ]
    },
    {
        "id": "ad4fc4580773a583",
        "type": "ui-chart",
        "z": "190ed3e96d0709a5",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-07",
        "label": "Volumen FA-07",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "200000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1800,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "fcbfd2b58ba9ac83",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-1', \n                equipo_id: 'FA-01', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1950,
        "y": 480,
        "wires": [
            [
                "c2f402fd7de228b2"
            ]
        ]
    },
    {
        "id": "c2f402fd7de228b2",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "190ed3e96d0709a5",
        "server": "a1b3d7fc83d5c6f6",
        "name": "DB",
        "x": 2190,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "d250c11d6dec42a9",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-9', \n                equipo_id: 'FA-09', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 620,
        "wires": [
            [
                "c2f402fd7de228b2"
            ]
        ]
    },
    {
        "id": "d68d9ad9e6ba918a",
        "type": "function",
        "z": "190ed3e96d0709a5",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-7', \n                equipo_id: 'FA-07', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 720,
        "wires": [
            [
                "c2f402fd7de228b2"
            ]
        ]
    },
    {
        "id": "a77fa9701c726221",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "debug 42",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1600,
        "y": 440,
        "wires": []
    },
    {
        "id": "58303efc8fb8844e",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "debug 43",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 500,
        "wires": []
    },
    {
        "id": "e88437c06ce5e178",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 620,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "7ff3dc8119cca4d3",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "ADC_2_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 500,
        "y": 660,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "1e8be9ee0af07cce",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 500,
        "y": 580,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "2f776b033e7cd327",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 540,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "fb726970df3a5a11",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 470,
        "y": 360,
        "wires": [
            [
                "0c548bd3de817c51"
            ]
        ]
    },
    {
        "id": "88b118ad8adef70d",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 470,
        "y": 400,
        "wires": [
            [
                "23cbf47d22124f5a"
            ]
        ]
    },
    {
        "id": "0c548bd3de817c51",
        "type": "change",
        "z": "190ed3e96d0709a5",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 650,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "23cbf47d22124f5a",
        "type": "change",
        "z": "190ed3e96d0709a5",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 670,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "a82d87f1056b77c2",
        "type": "inject",
        "z": "190ed3e96d0709a5",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "reset",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 500,
        "wires": [
            [
                "a1d380aff2236a21"
            ]
        ]
    },
    {
        "id": "9f254561809fe947",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "Status Queue",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 920,
        "y": 820,
        "wires": []
    },
    {
        "id": "2f6892ae26582cc0",
        "type": "debug",
        "z": "190ed3e96d0709a5",
        "name": "update log",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1090,
        "y": 780,
        "wires": []
    },
    {
        "id": "ab77e3b0be16441c",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI0",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":40,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 420,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "fd46ad6b8843e95e",
        "type": "change",
        "z": "4f1c58c90aef2801",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 560,
        "y": 440,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "e0f9ab2ec51ce602",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic === \"\") || (msg.topic === null) || (msg.topic === undefined)) {\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Topic missing\" });\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current > 0) && (current % resendinterval === 0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg !== undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state === 1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\", []);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i = queue.length - 1; i >= 0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i, 1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\", queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length > 0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0, 1);\n        context.set(\"queue\", queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return [newmsg, null, null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n\n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 560,
        "wires": [
            [
                "70471518d5fa5df4"
            ],
            [],
            [
                "8050baee79313da6",
                "ca50c8da91087b3c"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "8050baee79313da6",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 600,
        "wires": [
            [
                "dafbc58d04cb9995"
            ]
        ]
    },
    {
        "id": "a471b5f442e7dd47",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 700,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "a9f7ca731edbcb8b",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI1",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":41,\"quantity\":1}",
        "payloadType": "json",
        "x": 210,
        "y": 460,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "8e1884802ce9f6c0",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI2",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":42,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 500,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "073779b13bf18f48",
        "type": "switch",
        "z": "4f1c58c90aef2801",
        "name": "ADC3 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC3_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI4",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI5",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI6",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC3_AI7",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 8,
        "x": 960,
        "y": 440,
        "wires": [
            [
                "c7621a1f1897c3a5"
            ],
            [
                "83b40c324c670d95"
            ],
            [
                "08216224f5fd3608"
            ],
            [],
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "469167ab978a5033",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI3",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":43,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "05689b7dff66f908",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI4",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":44,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "b431110895da16a1",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI5",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI5",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":45,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "ecdc72f09b9ececa",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "ADC3_AI6",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC3_AI6",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":46,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "c7621a1f1897c3a5",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "calc_vol_FA-04",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (65000 - 3200);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 320,
        "wires": [
            [
                "557237e248b7dc62",
                "ac3a9923480b6a67",
                "5525db57403cc012",
                "391fb7592ef9f2b2"
            ],
            []
        ]
    },
    {
        "id": "557237e248b7dc62",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 240,
        "wires": [
            [
                "d55dae7b3a90f13d"
            ]
        ]
    },
    {
        "id": "ac3a9923480b6a67",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 200,
        "wires": [
            [
                "06c43dbe5b22b8a6"
            ]
        ]
    },
    {
        "id": "5525db57403cc012",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "vol_FA-04",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1500,
        "y": 320,
        "wires": []
    },
    {
        "id": "08216224f5fd3608",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "calc_vol_FA-06A",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (51600 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 400,
        "wires": [
            [
                "80759972356d7f6a",
                "ab5c669f3b6e56e3",
                "8317da5af486e3b8",
                "dcc7e839ba2a5567"
            ],
            []
        ]
    },
    {
        "id": "80759972356d7f6a",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 400,
        "wires": [
            [
                "f5299b1650911717"
            ]
        ]
    },
    {
        "id": "ab5c669f3b6e56e3",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 360,
        "wires": [
            [
                "9717f724ef7d6c9f"
            ]
        ]
    },
    {
        "id": "8317da5af486e3b8",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "vol_FA-06A",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 480,
        "wires": []
    },
    {
        "id": "83b40c324c670d95",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "calc_vol_FA-06B",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (94100 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 540,
        "wires": [
            [
                "c80a6e94848ba081",
                "02b9dcee13d97f5a",
                "3cf04a5870f50ee4",
                "4bc7cfceb55f96bb"
            ],
            []
        ]
    },
    {
        "id": "c80a6e94848ba081",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 580,
        "wires": [
            [
                "7047b915d06ac299"
            ]
        ]
    },
    {
        "id": "02b9dcee13d97f5a",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 540,
        "wires": [
            [
                "57403451691dd1ad"
            ]
        ]
    },
    {
        "id": "3cf04a5870f50ee4",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "vol_FA-06B",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1470,
        "y": 660,
        "wires": []
    },
    {
        "id": "70471518d5fa5df4",
        "type": "modbus-flex-getter",
        "z": "4f1c58c90aef2801",
        "name": "ADC3",
        "showStatusActivities": true,
        "showErrors": true,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "661d09df777a5259",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 690,
        "y": 540,
        "wires": [
            [
                "fd46ad6b8843e95e",
                "073779b13bf18f48"
            ],
            []
        ]
    },
    {
        "id": "06c43dbe5b22b8a6",
        "type": "ui-chart",
        "z": "4f1c58c90aef2801",
        "group": "90c50477d9bdd042",
        "name": "Volumen FA-04",
        "label": "Volumen FA-04",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "63000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1640,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "9717f724ef7d6c9f",
        "type": "ui-chart",
        "z": "4f1c58c90aef2801",
        "group": "90c50477d9bdd042",
        "name": "Volumen FA-06A",
        "label": "Volumen FA-06A",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "54000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1650,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "57403451691dd1ad",
        "type": "ui-chart",
        "z": "4f1c58c90aef2801",
        "group": "90c50477d9bdd042",
        "name": "Volumen FA-06B",
        "label": "Volumen FA-06B",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "93000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1650,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "391fb7592ef9f2b2",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-4',\n                equipo_id: 'FA-04',\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 280,
        "wires": [
            [
                "0e9bc527bc20300f"
            ]
        ]
    },
    {
        "id": "0e9bc527bc20300f",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "4f1c58c90aef2801",
        "server": "a1b3d7fc83d5c6f6",
        "name": "DB",
        "x": 1950,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "dcc7e839ba2a5567",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-6A',\n                equipo_id: 'FA-06A',\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 440,
        "wires": [
            [
                "0e9bc527bc20300f"
            ]
        ]
    },
    {
        "id": "4bc7cfceb55f96bb",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-6B',\n                equipo_id: 'FA-06B',\n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 620,
        "wires": [
            [
                "0e9bc527bc20300f"
            ]
        ]
    },
    {
        "id": "d55dae7b3a90f13d",
        "type": "mqtt out",
        "z": "4f1c58c90aef2801",
        "name": "mqtt_tb_MN-4",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "74e31200f882aea8",
        "x": 1640,
        "y": 240,
        "wires": []
    },
    {
        "id": "f5299b1650911717",
        "type": "mqtt out",
        "z": "4f1c58c90aef2801",
        "name": "mqtt_tb_MN-6A",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "714e095421e2277c",
        "x": 1660,
        "y": 400,
        "wires": []
    },
    {
        "id": "7047b915d06ac299",
        "type": "mqtt out",
        "z": "4f1c58c90aef2801",
        "name": "mqtt_tb_MN-6B",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "3e658c694e790b36",
        "x": 1660,
        "y": 580,
        "wires": []
    },
    {
        "id": "1c7ded7911537f86",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "Watchdog Check",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "watchdog",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 820,
        "wires": [
            [
                "67c7a396cf4426e5"
            ]
        ]
    },
    {
        "id": "67c7a396cf4426e5",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "Check Connection",
        "func": "const lastUpdate = context.get('lastUpdate') || 0;\nconst now = Date.now();\nconst threshold = 60000; // 60 seconds\n\nif (now - lastUpdate > threshold) {\n    // Connection lost\n    return [null, {payload: 'reset'}];\n} else {\n    // Connection OK\n    return [{payload: 'OK'}, null];\n}\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 820,
        "wires": [
            [],
            [
                "544ccd9ff96b0984"
            ]
        ]
    },
    {
        "id": "544ccd9ff96b0984",
        "type": "function",
        "z": "4f1c58c90aef2801",
        "name": "Reset Modbus",
        "func": "// This function will attempt to reset the Modbus client\n// You may need to adjust this based on your specific Modbus client configuration\nconst modbusConfig = global.get('modbus-config');\nif (modbusConfig) {\n    modbusConfig.reconnect();\n    node.status({fill:\"yellow\",shape:\"ring\",text:\"Reconnecting...\"});\n    return {payload: \"Attempting to reconnect Modbus client\"};\n} else {\n    node.status({fill:\"red\",shape:\"ring\",text:\"No Modbus config found\"});\n    return {payload: \"Error: No Modbus configuration found\"};\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "e76302d7022b3b33",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "reset",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 300,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "2ed1d18b792632d9",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 340,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "5f35fa7167a15493",
        "type": "inject",
        "z": "4f1c58c90aef2801",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 220,
        "y": 380,
        "wires": [
            [
                "e0f9ab2ec51ce602"
            ]
        ]
    },
    {
        "id": "ca50c8da91087b3c",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "Status Queue",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 640,
        "wires": []
    },
    {
        "id": "dafbc58d04cb9995",
        "type": "debug",
        "z": "4f1c58c90aef2801",
        "name": "update log",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 810,
        "y": 600,
        "wires": []
    },
    {
        "id": "7346e461e4b1c18f",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor numérico\nreturn msg;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 300,
        "wires": [
            [
                "66ff9460a01c6324"
            ],
            []
        ]
    },
    {
        "id": "66ff9460a01c6324",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// Añadir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no está disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros más antiguos que el tiempo máximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 280,
        "wires": [
            [
                "5a92dc2c750f0ec5"
            ]
        ]
    },
    {
        "id": "5a92dc2c750f0ec5",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Flow Calculation Node",
        "func": "const RELLENANDO_KEY = \"rellenando\";\nconst FLUJOS_RECIENTES_KEY = \"flujosRecientes\";\nconst COLA_VACIADO_KEY = \"colaVaciado\";\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0) {\n        return Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nfunction estaRellenando(cola) {\n    if (cola.length < 2) return false;\n    const cambioVolumen = cola[cola.length - 1].volumen - cola[0].volumen;\n    return cambioVolumen > 150;\n}\n\nfunction obtenerPromedioFlujo(flujosRecientes) {\n    if (flujosRecientes.length === 0) return 0;\n    const suma = flujosRecientes.reduce((a, b) => a + b, 0);\n    return Math.round(suma / flujosRecientes.length);\n}\n\n// Función principal\nconst cola = msg.payload;\nlet flujo = 0;\nlet rellenando = flow.get(RELLENANDO_KEY) || false;\nlet flujosRecientes = flow.get(FLUJOS_RECIENTES_KEY) || [];\nlet colaVaciado = flow.get(COLA_VACIADO_KEY) || [];\n\nif (estaRellenando(cola)) {\n    if (!rellenando) {\n        rellenando = true;\n        flow.set(RELLENANDO_KEY, true);\n        node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando flujo promedio\"});\n    }\n    flujo = obtenerPromedioFlujo(flujosRecientes);\n    colaVaciado = []; // Reiniciar la cola de vaciado\n} else {\n    if (rellenando) {\n        // El rellenado acaba de terminar\n        rellenando = false;\n        flow.set(RELLENANDO_KEY, false);\n        colaVaciado = []; // Iniciar una nueva cola de vaciado\n        node.status({fill:\"green\", shape:\"dot\", text:\"Operación normal - Iniciando nuevo vaciado\"});\n    }\n    \n    // Añadir el nuevo registro a la cola de vaciado\n    colaVaciado.push(cola[cola.length - 1]);\n    \n    // Mantener solo los últimos 10 registros en la cola de vaciado\n    if (colaVaciado.length > 10) colaVaciado.shift();\n    \n    // Calcular el flujo usando la cola de vaciado\n    flujo = calcularFlujo(colaVaciado);\n    \n    // Actualizar flujos recientes solo si es una medición válida\n    if (flujo > 0 && flujo <= 10000) {\n        flujosRecientes.push(flujo);\n        if (flujosRecientes.length > 10) flujosRecientes.shift();\n        flow.set(FLUJOS_RECIENTES_KEY, flujosRecientes);\n    }\n}\n\n// Guardar la cola de vaciado actualizada\nflow.set(COLA_VACIADO_KEY, colaVaciado);\n\nreturn { payload: flujo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 220,
        "wires": [
            [
                "dd8dae85c35d04e4"
            ]
        ]
    },
    {
        "id": "dd8dae85c35d04e4",
        "type": "ui-gauge",
        "z": "0a1446a2506c6a05",
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 940,
        "y": 220,
        "wires": []
    },
    {
        "id": "a04c9a1bff1e8e9c",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor numérico\nreturn msg;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 520,
        "wires": [
            [
                "e459b3f5a855d75d"
            ],
            []
        ]
    },
    {
        "id": "e459b3f5a855d75d",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// Añadir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no está disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros más antiguos que el tiempo máximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 480,
        "wires": [
            [
                "f64f9862a7fe2280"
            ]
        ]
    },
    {
        "id": "f64f9862a7fe2280",
        "type": "function",
        "z": "0a1446a2506c6a05",
        "name": "Flow Calculation Node",
        "func": "// Contexto del flujo para mantener el estado\nconst RELLENANDO_KEY = \"rellenando\";\nconst FLUJOS_RECIENTES_KEY = \"flujosRecientes\";\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    // Convertir los valores de volumen según la escala proporcionada\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0) {\n        return Math.round(-((volumenFinal - volumenInicial) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nfunction estaRellenando(cola) {\n    if (cola.length < 2) return false;\n    const cambioVolumen = cola[cola.length - 1].volumen - cola[0].volumen;\n    return cambioVolumen > 150; // Considera rellenando si el volumen aumenta más de 50 unidades\n}\n\nfunction obtenerPromedioFlujo(flujosRecientes) {\n    if (flujosRecientes.length === 0) return 0;\n    const suma = flujosRecientes.reduce((a, b) => a + b, 0);\n    return Math.round(suma / flujosRecientes.length);\n}\n\n// Función principal\nconst cola = msg.payload;\nlet flujo = 0;\nlet rellenando = flow.get(RELLENANDO_KEY) || false;\nlet flujosRecientes = flow.get(FLUJOS_RECIENTES_KEY) || [];\n\nif (estaRellenando(cola)) {\n    if (!rellenando) {\n        // Acaba de comenzar el rellenado\n        rellenando = true;\n        flow.set(RELLENANDO_KEY, true);\n        node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando flujo promedio\"});\n    }\n    flujo = obtenerPromedioFlujo(flujosRecientes);\n} else {\n    if (rellenando) {\n        // El rellenado acaba de terminar\n        rellenando = false;\n        flow.set(RELLENANDO_KEY, false);\n        node.status({fill:\"green\", shape:\"dot\", text:\"Operación normal\"});\n    }\n    flujo = calcularFlujo(cola);\n    \n    // Actualizar flujos recientes solo si es una medición válida\n    if (flujo > 0 && flujo <= 10000) { // Asumiendo que el flujo máximo es 10000 L/h\n        flujosRecientes.push(flujo);\n        // Mantener solo las últimas 10 mediciones válidas\n        if (flujosRecientes.length > 10) flujosRecientes.shift();\n        flow.set(FLUJOS_RECIENTES_KEY, flujosRecientes);\n    }\n}\n\nreturn { payload: flujo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 420,
        "wires": [
            [
                "5be5b51bca193b4c"
            ]
        ]
    },
    {
        "id": "5be5b51bca193b4c",
        "type": "ui-gauge",
        "z": "0a1446a2506c6a05",
        "name": "Flujo Residuo",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo Residuo",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 970,
        "y": 420,
        "wires": []
    },
    {
        "id": "2c9c96b466a66dbf",
        "type": "change",
        "z": "0eebc14e6b9c0fb5",
        "name": "Avanzar cola",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 870,
        "y": 640,
        "wires": [
            [
                "60ce4aa7d2756d25"
            ]
        ]
    },
    {
        "id": "60ce4aa7d2756d25",
        "type": "function",
        "z": "0eebc14e6b9c0fb5",
        "name": "Cola Modbus",
        "func": "// Parámetros de configuración\nconst resendIfNoResponse = true;\nconst resendInterval = 10; // segundos\nconst onlineThreshold = 10; // segundos\nconst offlineThreshold = 300; // segundos\n\n// Inicialización de variables de contexto\nlet lastUpdate = context.get('lastUpdate') || 0;\nlet state = context.get('state') || 0;\nlet queue = context.get('queue') || [];\nlet sent = context.get('sent') || false;\nlet lastMsg = context.get('lastMsg');\n\n// Obtener tiempo actual\nlet currentTime = new Date().getTime();\nlet sendMsg = false;\nlet notifMsg = null;\n\n// Asegurarse de que el mensaje entrante tenga un tópico\nif (!msg.topic) {\n    node.status({ fill: 'red', shape: 'dot', text: 'Tópico faltante' });\n    return;\n}\n\nswitch (msg.topic.toLowerCase()) {\n    case 'update':\n        // Manejo de actualizaciones de estado\n        if (lastUpdate) {\n            const timeDiff = Math.floor((currentTime - lastUpdate) / 1000);\n            notifMsg = {\n                topic: 'Información',\n                payload: {\n                    secondsSinceLastUpdate: timeDiff,\n                    updateText: ''\n                }\n            };\n\n            // Formatear texto de actualización\n            let seconds = timeDiff % 60;\n            let minutes = Math.floor(timeDiff / 60) % 60;\n            let hours = Math.floor(timeDiff / 3600) % 24;\n            let days = Math.floor(timeDiff / 86400);\n            if (days > 0) {\n                notifMsg.payload.updateText = `Última actualización hace ${days} días, ${hours} horas, ${minutes} minutos, ${seconds} segundos`;\n            } else if (hours > 0) {\n                notifMsg.payload.updateText = `Última actualización hace ${hours} horas, ${minutes} minutos, ${seconds} segundos`;\n            } else if (minutes > 0) {\n                notifMsg.payload.updateText = `Última actualización hace ${minutes} minutos, ${seconds} segundos`;\n            } else {\n                notifMsg.payload.updateText = `Última actualización hace ${seconds} segundos`;\n            }\n\n            // Reenviar último mensaje si no hay respuesta\n            if (resendIfNoResponse && timeDiff > 0 && timeDiff % resendInterval === 0) {\n                if (lastMsg && context.get('sent')) {\n                    notifMsg.payload.resend = true;\n                    if ([1, 2, 3, 4].includes(lastMsg.payload.fc)) {\n                        node.status({ fill: 'green', shape: 'dot', text: 'Lectura reenviada' });\n                        return [lastMsg, null, notifMsg];\n                    } else {\n                        node.status({ fill: 'green', shape: 'dot', text: 'Escritura reenviada' });\n                        return [null, lastMsg, notifMsg];\n                    }\n                }\n            }\n\n            // Verificar estado en línea/fuera de línea\n            if (state !== 1 && timeDiff < onlineThreshold) {\n                notifMsg.topic = 'Warning';\n                notifMsg.payload.text = 'Dispositivo en línea';\n                notifMsg.payload.statusChange = true;\n                state = 1;\n                context.set('state', state);\n            } else if (state === 1 && timeDiff > offlineThreshold) {\n                notifMsg.topic = 'Error';\n                notifMsg.payload.text = 'Dispositivo fuera de línea';\n                notifMsg.payload.statusChange = true;\n                state = 99;\n                context.set('state', state);\n            }\n            notifMsg.payload.state = state;\n            if (state === 1) {\n                node.status({ fill: 'blue', shape: 'ring', text: queue.length + ' | ' + notifMsg.payload.updateText });\n            } else {\n                node.status({ fill: 'red', shape: 'ring', text: queue.length + ' | ' + notifMsg.payload.updateText });\n            }\n            return [null, null, notifMsg];\n        } else {\n            node.status({ fill: 'grey', shape: 'ring', text: 'Sin datos' });\n        }\n        break;\n    case 'next':\n        // Preparar para enviar el siguiente mensaje\n        context.set('lastUpdate', currentTime);\n        context.set('sent', false);\n        sendMsg = true;\n        break;\n    case 'reset':\n        // Reiniciar la cola y variables de contexto\n        context.set('queue', []);\n        context.set('sent', false);\n        context.set('lastMsg', undefined);\n        break;\n    default:\n        // Agregar mensaje a la cola\n        queue = queue.filter(item => item.topic !== msg.topic);\n        queue.push(msg);\n        context.set('queue', queue);\n        if (!sent) {\n            sendMsg = true;\n        }\n        node.status({ fill: 'green', shape: 'dot', text: queue.length.toString() });\n}\n\n// Enviar el siguiente mensaje si corresponde\nif (sendMsg) {\n    if (queue.length > 0) {\n        const nextMsg = queue.shift();\n        context.set('queue', queue);\n        context.set('sent', true);\n        context.set('lastMsg', nextMsg);\n        if ([1, 2, 3, 4].includes(nextMsg.payload.fc)) {\n            node.status({ fill: 'green', shape: 'dot', text: 'Lectura enviada' });\n            return [nextMsg, null, null];\n        } else {\n            node.status({ fill: 'green', shape: 'dot', text: 'Escritura enviada' });\n            return [null, nextMsg, null];\n        }\n    }\n}\n\nreturn;",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 820,
        "wires": [
            [
                "846f104be6efb4ce"
            ],
            [],
            [
                "9de52222f2023abd"
            ]
        ]
    },
    {
        "id": "846f104be6efb4ce",
        "type": "modbus-flex-getter",
        "z": "0eebc14e6b9c0fb5",
        "name": "ADC2 Lectura Agrupada",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": false,
        "logIOActivities": false,
        "server": "661d09df777a5259",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 990,
        "y": 820,
        "wires": [
            [
                "a1e1aa03ad56b0d4",
                "2c9c96b466a66dbf"
            ],
            []
        ]
    },
    {
        "id": "a1e1aa03ad56b0d4",
        "type": "function",
        "z": "0eebc14e6b9c0fb5",
        "name": "Procesar Datos Modbus",
        "func": "// Procesar las lecturas y enviar a procesamiento\nconst valores = msg.payload.data;\nconst topics = ['read_ADC2_AI1', 'read_ADC2_AI2', 'read_ADC2_AI3', 'read_ADC2_AI4'];\n\nvalores.forEach((valor, index) => {\n    node.send({ topic: topics[index], payload: valor });\n});\nreturn;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1290,
        "y": 820,
        "wires": [
            [
                "3d1e032097bb8c5f"
            ]
        ]
    },
    {
        "id": "3d1e032097bb8c5f",
        "type": "subflow:1b6aa974e2ca303d",
        "z": "0eebc14e6b9c0fb5",
        "name": "",
        "env": [],
        "x": 1580,
        "y": 820,
        "wires": []
    },
    {
        "id": "c96b42be80162ffe",
        "type": "inject",
        "z": "0eebc14e6b9c0fb5",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": "0.1",
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 540,
        "y": 820,
        "wires": [
            [
                "60ce4aa7d2756d25"
            ]
        ]
    },
    {
        "id": "9de52222f2023abd",
        "type": "debug",
        "z": "0eebc14e6b9c0fb5",
        "name": "Status Queue",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 980,
        "y": 1020,
        "wires": []
    },
    {
        "id": "7a370c4b85b29ef1",
        "type": "change",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 520,
        "y": 380,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "b6d76655df7188ed",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic === \"\") || (msg.topic === null) || (msg.topic === undefined)) {\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Topic missing\" });\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current > 0) && (current % resendinterval === 0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg !== undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state === 1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\", []);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i = queue.length - 1; i >= 0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i, 1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\", queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length > 0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0, 1);\n        context.set(\"queue\", queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return [newmsg, null];\n        }\n    }\n}\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 600,
        "wires": [
            [
                "f8cd8be83e8d7779"
            ],
            [
                "6020fdaefe40e9e9",
                "dbe8eeeae1738d95"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "6020fdaefe40e9e9",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 640,
        "wires": [
            [
                "4437fa47ecc90bd8"
            ]
        ]
    },
    {
        "id": "d30a2726478f36f2",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 640,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "a581f35f17e7f31a",
        "type": "switch",
        "z": "663b1dbab4a22bc2",
        "name": "ADC2 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC2_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC2_AI4",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 900,
        "y": 540,
        "wires": [
            [
                "2c33bc86e7e229dd",
                "f8a3db9f9da14a3a"
            ],
            [
                "382644640ba019db"
            ],
            [
                "42d44f36569664ef"
            ],
            []
        ]
    },
    {
        "id": "6aa381426e6839ae",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 560,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "a09997d276d37f9b",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 600,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "382644640ba019db",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "calc_vol_FA-01",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (115500 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 420,
        "wires": [
            [
                "01c83f97683a617c",
                "a72c0d79c119556d",
                "0a4519ce7547ab03",
                "074fcbdf083ad42d",
                "cafbced0c971836b"
            ],
            []
        ]
    },
    {
        "id": "cfce2dc9702f3525",
        "type": "mqtt out",
        "z": "663b1dbab4a22bc2",
        "name": "mqtt_tb_MN-1",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "7ac8f4b3a29c864f",
        "x": 1500,
        "y": 440,
        "wires": []
    },
    {
        "id": "01c83f97683a617c",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 440,
        "wires": [
            [
                "cfce2dc9702f3525"
            ]
        ]
    },
    {
        "id": "a72c0d79c119556d",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 380,
        "wires": [
            [
                "3cc4a1f763f95c56"
            ]
        ]
    },
    {
        "id": "0a4519ce7547ab03",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "vol_FA-01",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1660,
        "y": 420,
        "wires": []
    },
    {
        "id": "f8a3db9f9da14a3a",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "calc_vol_FA-09",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (19000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 520,
        "wires": [
            [
                "67eff7b1d9e6b2ae",
                "8547335518cfc9b7",
                "8f578d08a192bb37",
                "c54458e807e51ddb"
            ],
            []
        ]
    },
    {
        "id": "5107b776e5769d96",
        "type": "mqtt out",
        "z": "663b1dbab4a22bc2",
        "name": "mqtt_tb_MN-9",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "bb61bb0c49cb82b4",
        "x": 1500,
        "y": 540,
        "wires": []
    },
    {
        "id": "67eff7b1d9e6b2ae",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 540,
        "wires": [
            [
                "5107b776e5769d96"
            ]
        ]
    },
    {
        "id": "8547335518cfc9b7",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 500,
        "wires": [
            [
                "e71d9fecf061811a"
            ]
        ]
    },
    {
        "id": "8f578d08a192bb37",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "vol_FA-09",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1660,
        "y": 520,
        "wires": []
    },
    {
        "id": "42d44f36569664ef",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "calc_vol_FA-07",
        "func": "const valorCrudo = msg.payload;\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (200000 - 0);\nmsg.payload = Math.round(valorLitros);\nreturn msg;",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 640,
        "wires": [
            [
                "90fadc97f372d9f0",
                "dcaf92fde199c17f",
                "beffc6045a7dc2c2",
                "f677d22be9fdf34e"
            ],
            []
        ]
    },
    {
        "id": "e1c29a6e3db2cc13",
        "type": "mqtt out",
        "z": "663b1dbab4a22bc2",
        "name": "mqtt_tb_MN-7",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "aeb8c7546d28ce5c",
        "x": 1500,
        "y": 640,
        "wires": []
    },
    {
        "id": "90fadc97f372d9f0",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 640,
        "wires": [
            [
                "e1c29a6e3db2cc13"
            ]
        ]
    },
    {
        "id": "dcaf92fde199c17f",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 600,
        "wires": [
            [
                "1ddf871b6e31e48b"
            ]
        ]
    },
    {
        "id": "beffc6045a7dc2c2",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "vol_FA-07",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1680,
        "y": 620,
        "wires": []
    },
    {
        "id": "f8cd8be83e8d7779",
        "type": "modbus-flex-getter",
        "z": "663b1dbab4a22bc2",
        "name": "ADC2",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": false,
        "logIOActivities": false,
        "server": "661d09df777a5259",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 630,
        "y": 520,
        "wires": [
            [
                "7a370c4b85b29ef1",
                "a581f35f17e7f31a",
                "43a3a5014bf1b89c",
                "8661a36563068020"
            ],
            []
        ]
    },
    {
        "id": "3cc4a1f763f95c56",
        "type": "ui-chart",
        "z": "663b1dbab4a22bc2",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-01",
        "label": "Volumen FA-01",
        "order": 1,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "105000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1520,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "e71d9fecf061811a",
        "type": "ui-chart",
        "z": "663b1dbab4a22bc2",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-09",
        "label": "Volumen FA-09",
        "order": 3,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "20000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1520,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "1ddf871b6e31e48b",
        "type": "ui-chart",
        "z": "663b1dbab4a22bc2",
        "group": "3f690bb5a526a246",
        "name": "Volumen FA-07",
        "label": "Volumen FA-07",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "200000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1520,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "074fcbdf083ad42d",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-1', \n                equipo_id: 'FA-01', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 340,
        "wires": [
            [
                "e08c188598820f43"
            ]
        ]
    },
    {
        "id": "c54458e807e51ddb",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-9', \n                equipo_id: 'FA-09', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 480,
        "wires": [
            [
                "e08c188598820f43"
            ]
        ]
    },
    {
        "id": "f677d22be9fdf34e",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "F_influx_vol",
        "func": "msg.payload = {\n    bucket: 'sensores',\n    precision: 'ms',\n    data: [\n        {\n            measurement: 'ParametrosProceso',\n            tags: {\n                sensor_id: 'MN-7', \n                equipo_id: 'FA-07', \n                ubicacion: 'destilados'\n            },\n            fields: {\n                nivel_litros: msg.payload\n            },\n            timestamp: Date.now()\n        }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 580,
        "wires": [
            [
                "e08c188598820f43"
            ]
        ]
    },
    {
        "id": "cafbced0c971836b",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 42",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1320,
        "y": 300,
        "wires": []
    },
    {
        "id": "2c33bc86e7e229dd",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 43",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1020,
        "y": 360,
        "wires": []
    },
    {
        "id": "1f63aa4adb2f4e24",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 480,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "6cdd06e2ed6cd4f5",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "ADC_2_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 220,
        "y": 520,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "5b8a04908c59a547",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 220,
        "y": 440,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "e9367193c598413a",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 400,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "d3421cf0ddf70bf6",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 220,
        "wires": [
            [
                "0e493184c01a2490"
            ]
        ]
    },
    {
        "id": "7bdf0bcecb85ba5f",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 260,
        "wires": [
            [
                "657f3cbe468c3137"
            ]
        ]
    },
    {
        "id": "0e493184c01a2490",
        "type": "change",
        "z": "663b1dbab4a22bc2",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 370,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "657f3cbe468c3137",
        "type": "change",
        "z": "663b1dbab4a22bc2",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 390,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "f69cb68a7a2891f6",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "d": true,
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "reset",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 360,
        "wires": [
            [
                "b6d76655df7188ed"
            ]
        ]
    },
    {
        "id": "dbe8eeeae1738d95",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "Status Queue",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 640,
        "y": 680,
        "wires": []
    },
    {
        "id": "4437fa47ecc90bd8",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 810,
        "y": 640,
        "wires": []
    },
    {
        "id": "e08c188598820f43",
        "type": "Stackhero-InfluxDB-v2-write",
        "z": "663b1dbab4a22bc2",
        "server": "a1b3d7fc83d5c6f6",
        "name": "DB",
        "x": 1910,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "43a3a5014bf1b89c",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 86",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 440,
        "wires": []
    },
    {
        "id": "3444a03605a05621",
        "type": "catch",
        "z": "663b1dbab4a22bc2",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 180,
        "y": 100,
        "wires": [
            [
                "b4624e19ee28a93a"
            ]
        ]
    },
    {
        "id": "b4624e19ee28a93a",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 92",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 100,
        "wires": []
    },
    {
        "id": "aadd6626fd1e9fbb",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "function 40",
        "func": "let topics = [\n    { topic: \"read_ADC2_AI1\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 0, \"quantity\": 1 } },\n    { topic: \"read_ADC2_AI2\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 1, \"quantity\": 1 } },\n    { topic: \"read_ADC2_AI3\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 2, \"quantity\": 1 } },\n    { topic: \"read_ADC2_AI4\", payload: { \"value\": 0, \"fc\": 4, \"unitid\": 1, \"address\": 3, \"quantity\": 1 } }\n];\n\nlet currentTopicIndex = context.get(\"currentTopicIndex\") || 0; // Track the current topic\nlet sendInterval = 2 * 1000; // 2-second interval for each topic (modifiable)\nlet currentTime = new Date().getTime();\nlet lastSentTime = context.get(\"lastSentTime\") || 0;\nlet queue = context.get(\"queue\") || [];\nlet state = context.get(\"state\") || 0;\nlet send = false;\nlet notifmsg = null; // Message for logging purposes\n\n// Retrieve the current topic and its associated payload\nlet currentTopic = topics[currentTopicIndex];\n\n// Calculate the time difference since the last message was sent\nlet timeDifference = currentTime - lastSentTime;\n\n// Check if it's time to send the next message for the current topic\nif (timeDifference >= sendInterval) {\n    // Add the current topic's Modbus read request to the queue\n    queue.push({ topic: currentTopic.topic, payload: currentTopic.payload });\n    context.set(\"queue\", queue);\n    context.set(\"lastSentTime\", currentTime);\n\n    // Prepare to send the message\n    send = true;\n\n    // Move to the next topic for the next cycle\n    currentTopicIndex = (currentTopicIndex + 1) % topics.length;\n    context.set(\"currentTopicIndex\", currentTopicIndex);\n\n    // Logging message preparation (2nd output)\n    notifmsg = { topic: \"Information\", payload: {} };\n    notifmsg.payload.updatetext = `Request sent for ${currentTopic.topic}`;\n\n    // Display the current status\n    node.status({ fill: \"green\", shape: \"dot\", text: `Request sent for ${currentTopic.topic}` });\n}\n\n// Check for device state and log warnings/errors if needed\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds above which the device is considered offline\n\nif (state !== 1) {\n    if (timeDifference < online_threshold) {\n        notifmsg = { topic: \"Warning\", payload: { text: \"Device is now online\", statuschange: true } };\n        state = 1; // Device is online\n        context.set(\"state\", state);\n    }\n} else {\n    if (timeDifference > offline_threshold) {\n        notifmsg = { topic: \"Error\", payload: { text: \"Device is not transmitting\", statuschange: true } };\n        state = 99; // Device is offline\n        context.set(\"state\", state);\n    }\n}\n\n// Send the Modbus request if ready\nif (send && queue.length > 0) {\n    let newMsg = queue.shift(); // Get the next message from the queue\n    context.set(\"queue\", queue);\n\n    // Return the Modbus request on the first output and logging on the second\n    return [newMsg, notifmsg];\n} else if (notifmsg) {\n    // In case there's no Modbus request but we still have a logging message\n    return [null, notifmsg];\n}\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 780,
        "wires": [
            [
                "f8cd8be83e8d7779"
            ],
            [
                "521ced58e89e6850"
            ]
        ]
    },
    {
        "id": "e9f422a45f69c88e",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 185,
        "y": 780,
        "wires": [
            [
                "aadd6626fd1e9fbb"
            ]
        ],
        "l": false
    },
    {
        "id": "521ced58e89e6850",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 860,
        "wires": [
            [
                "c5f92984658a6eac"
            ]
        ]
    },
    {
        "id": "c5f92984658a6eac",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "update log",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 860,
        "wires": []
    },
    {
        "id": "9de9318f1d39ccc2",
        "type": "inject",
        "z": "663b1dbab4a22bc2",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 185,
        "y": 980,
        "wires": [
            [
                "c916098a878a089a"
            ]
        ],
        "l": false
    },
    {
        "id": "c916098a878a089a",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "function 41",
        "func": "let reconnectInterval = 60000; \nlet connectionState = context.get(\"connectionState\") || \"disconnected\"; // Initial state\nlet lastConnectionAttempt = context.get(\"lastConnectionAttempt\") || 0;\nlet currentTime = new Date().getTime();\n\nif (connectionState === \"disconnected\") {\n    if (currentTime - lastConnectionAttempt >= reconnectInterval) {\n        node.status({ fill: \"yellow\", shape: \"ring\", text: \"Reconnecting...\" });\n\n        let reconnectSuccess = reconnectModbusConnection(); // Implement this function\n        if (reconnectSuccess) {\n            connectionState = \"connected\";\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Connected\" });\n        } else {\n            node.warn(\"Reconnection attempt failed.\");\n        }\n\n        context.set(\"lastConnectionAttempt\", currentTime);\n    }\n} else if (connectionState === \"connected\") {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Connected\" });\n}\n\ncontext.set(\"connectionState\", connectionState);\nreturn msg;\n\nfunction reconnectModbusConnection() {\n    let reconnectMsg = {\n        topic: \"modbusReConnect\",\n        payload: {}\n    };\n    node.send([reconnectMsg]);  // Send reconnect message\n    return true;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 980,
        "wires": [
            [
                "bfd67dee9362a0c2"
            ]
        ]
    },
    {
        "id": "bfd67dee9362a0c2",
        "type": "link out",
        "z": "663b1dbab4a22bc2",
        "name": "link out 52",
        "mode": "link",
        "links": [
            "1ae9e1508ec9817c"
        ],
        "x": 475,
        "y": 980,
        "wires": []
    },
    {
        "id": "1ae9e1508ec9817c",
        "type": "link in",
        "z": "663b1dbab4a22bc2",
        "name": "link in 54",
        "links": [
            "bfd67dee9362a0c2"
        ],
        "x": 545,
        "y": 500,
        "wires": [
            [
                "f8cd8be83e8d7779"
            ]
        ]
    },
    {
        "id": "8661a36563068020",
        "type": "link out",
        "z": "663b1dbab4a22bc2",
        "name": "link out 53",
        "mode": "link",
        "links": [
            "af05fe1110900e68"
        ],
        "x": 705,
        "y": 560,
        "wires": []
    },
    {
        "id": "af05fe1110900e68",
        "type": "link in",
        "z": "663b1dbab4a22bc2",
        "name": "link in 55",
        "links": [
            "8661a36563068020"
        ],
        "x": 605,
        "y": 980,
        "wires": [
            [
                "9724f3e4f065af8e"
            ]
        ]
    },
    {
        "id": "9724f3e4f065af8e",
        "type": "function",
        "z": "663b1dbab4a22bc2",
        "name": "function 42",
        "func": "if (msg.payload.error || msg.payload.errorCode === \"ECONNREFUSED\") {\n    // Connection lost\n    context.set(\"connectionState\", \"disconnected\");\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Connection lost\" });\n} else if (msg.payload.status === \"connected\") {\n    // Successfully connected\n    context.set(\"connectionState\", \"connected\");\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Connected\" });\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 980,
        "wires": [
            [
                "77d6f29326f43c8a"
            ]
        ]
    },
    {
        "id": "77d6f29326f43c8a",
        "type": "debug",
        "z": "663b1dbab4a22bc2",
        "name": "debug 93",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 980,
        "wires": []
    },
    {
        "id": "984ab2045f44bcd5",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 600,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "7019d90458011b2a",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 760,
        "y": 560,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "aedffd40ec8c287c",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 980,
        "y": 680,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "011a5130f50f855b",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 800,
        "wires": [
            [
                "4fa27a733bf41ad4"
            ],
            [],
            [
                "4591bce234935eea"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "728fc737249824bf",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 750,
        "y": 520,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "a1c46aec8add99d8",
        "type": "link in",
        "z": "cf449ce1322fd8eb",
        "name": "link in 4",
        "links": [],
        "x": 795,
        "y": 480,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "4591bce234935eea",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "1c70cd3a4212709e",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 700,
        "y": 1020,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "e1a822778a0fd165",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor numérico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1700,
        "y": 480,
        "wires": [
            [
                "f9ca6a75d35d7d10",
                "840fc3448aa7be5e"
            ]
        ]
    },
    {
        "id": "c06d66220976b187",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Data Accumulation Node",
        "func": "let cola = flow.get(\"colaLecturas\") || [];\nconst tiempoMaximo = 300000; // 5 minutos en milisegundos\n\n// Añadir nuevo registro con timestamp actual si no viene incluido en el mensaje\nconst tiempoRegistro = msg.payload.timestamp || Date.now();  // Usar timestamp del mensaje o el tiempo actual si no está disponible\ncola.push({\n    tiempo: tiempoRegistro,\n    volumen: msg.payload[0] // Asumiendo que el volumen viene en msg.payload como primer elemento del array\n});\n\n// Eliminar registros más antiguos que el tiempo máximo permitido\nlet tiempoActual = Date.now();\ncola = cola.filter(registro => (tiempoActual - registro.tiempo) <= tiempoMaximo);\n\n// Guardar la cola actualizada en el contexto del flujo\nflow.set(\"colaLecturas\", cola);\n\n// Pasar la cola completa al siguiente nodo para su procesamiento\nreturn { payload: cola };\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1650,
        "y": 420,
        "wires": [
            [
                "ceea6d417693d667"
            ]
        ]
    },
    {
        "id": "ceea6d417693d667",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Flow Calculation Node",
        "func": "const RELLENANDO_KEY = \"rellenando\";\nconst FLUJOS_RECIENTES_KEY = \"flujosRecientes\";\nconst COLA_VACIADO_VALIDA_KEY = \"colaVaciadoValida\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nfunction estaRellenando(ultimoVolumen, nuevoVolumen) {\n    return nuevoVolumen > ultimoVolumen + 150; // Considera rellenando si el volumen aumenta más de 150 unidades\n}\n\nfunction obtenerPromedioFlujo(flujosRecientes) {\n    if (flujosRecientes.length === 0) return 0;\n    const suma = flujosRecientes.reduce((a, b) => a + b, 0);\n    return Math.round(suma / flujosRecientes.length);\n}\n\n// Función principal\nconst ultimaLectura = msg.payload[msg.payload.length - 1];\nlet flujo = 0;\nlet rellenando = flow.get(RELLENANDO_KEY) || false;\nlet flujosRecientes = flow.get(FLUJOS_RECIENTES_KEY) || [];\nlet colaVaciadoValida = flow.get(COLA_VACIADO_VALIDA_KEY) || [];\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || 0;\n\nif (estaRellenando(ultimoVolumen, ultimaLectura.volumen)) {\n    if (!rellenando) {\n        rellenando = true;\n        flow.set(RELLENANDO_KEY, true);\n        node.status({fill:\"yellow\", shape:\"ring\", text:\"Rellenando - Usando flujo promedio\"});\n    }\n    flujo = obtenerPromedioFlujo(flujosRecientes);\n    colaVaciadoValida = []; // Reiniciar la cola de vaciado válida\n} else {\n    if (rellenando) {\n        // El rellenado acaba de terminar\n        rellenando = false;\n        flow.set(RELLENANDO_KEY, false);\n        colaVaciadoValida = []; // Iniciar una nueva cola de vaciado válida\n        node.status({fill:\"green\", shape:\"dot\", text:\"Operación normal - Iniciando nuevo vaciado\"});\n    }\n    \n    // Añadir nuevo registro a la cola de vaciado válida\n    if (colaVaciadoValida.length === 0 || ultimaLectura.volumen < colaVaciadoValida[colaVaciadoValida.length - 1].volumen) {\n        colaVaciadoValida.push(ultimaLectura);\n    }\n    \n    // Mantener solo los últimos 5 minutos de datos válidos\n    const cincoMinutosAtras = Date.now() - 5 * 60 * 1000;\n    colaVaciadoValida = colaVaciadoValida.filter(registro => registro.tiempo >= cincoMinutosAtras);\n    \n    // Calcular el flujo usando solo los datos válidos\n    flujo = calcularFlujo(colaVaciadoValida);\n    \n    // Si no se puede calcular un flujo válido, usar el promedio de flujos recientes\n    if (flujo === 0 && flujosRecientes.length > 0) {\n        flujo = obtenerPromedioFlujo(flujosRecientes);\n    }\n    \n    // Actualizar flujos recientes solo si es una medición válida\n    if (flujo > 0 && flujo <= 10000) {\n        flujosRecientes.push(flujo);\n        if (flujosRecientes.length > 10) flujosRecientes.shift();\n        flow.set(FLUJOS_RECIENTES_KEY, flujosRecientes);\n    }\n}\n\n// Guardar el último volumen para la próxima ejecución\nflow.set(ULTIMO_VOLUMEN_KEY, ultimaLectura.volumen);\n\n// Guardar la cola de vaciado válida actualizada\nflow.set(COLA_VACIADO_VALIDA_KEY, colaVaciadoValida);\n\nreturn { payload: flujo };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1880,
        "y": 420,
        "wires": [
            [
                "8013d7446e6b7787",
                "739e2ec4f150a7c0",
                "0ca083d401370692"
            ]
        ]
    },
    {
        "id": "8013d7446e6b7787",
        "type": "debug",
        "z": "cf449ce1322fd8eb",
        "name": "Flujo COPE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2550,
        "y": 420,
        "wires": []
    },
    {
        "id": "4fa27a733bf41ad4",
        "type": "modbus-flex-getter",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1200,
        "y": 760,
        "wires": [
            [
                "aedffd40ec8c287c",
                "484a3352b3698f17"
            ],
            []
        ]
    },
    {
        "id": "484a3352b3698f17",
        "type": "switch",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI3",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1430,
        "y": 740,
        "wires": [
            [],
            [
                "e1a822778a0fd165",
                "c06d66220976b187"
            ],
            [],
            []
        ]
    },
    {
        "id": "739e2ec4f150a7c0",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "telemetria",
        "func": "msg.payload = {\n  flujo: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2060,
        "y": 420,
        "wires": [
            [
                "9d7ad836ba0bf6ed"
            ]
        ]
    },
    {
        "id": "f9ca6a75d35d7d10",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1840,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "9d7ad836ba0bf6ed",
        "type": "mqtt out",
        "z": "cf449ce1322fd8eb",
        "name": "mqtt_flujocope",
        "topic": "v1/devices/me/telemetry",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f344d91a44765e3a",
        "x": 2380,
        "y": 420,
        "wires": []
    },
    {
        "id": "0ca083d401370692",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "name": "Flujo COPE",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2210,
        "y": 420,
        "wires": []
    },
    {
        "id": "abed15d451c555f2",
        "type": "ui-chart",
        "z": "cf449ce1322fd8eb",
        "d": true,
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02",
        "label": "Volumen FA-02",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 2140,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "840fc3448aa7be5e",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1990,
        "y": 480,
        "wires": [
            [
                "abed15d451c555f2"
            ]
        ]
    },
    {
        "id": "cee38009337acfd3",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 360,
        "wires": [
            [
                "5b527a16a2653a03"
            ]
        ]
    },
    {
        "id": "7fe9d1241bda08c0",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 830,
        "y": 400,
        "wires": [
            [
                "3fdc5a44ea1c053c"
            ]
        ]
    },
    {
        "id": "5b527a16a2653a03",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1010,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "3fdc5a44ea1c053c",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1030,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "d40096130b974dce",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 680,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "1647bc6e4b31b983",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 720,
        "wires": [
            [
                "011a5130f50f855b"
            ]
        ]
    },
    {
        "id": "cec4be2929b61562",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI2",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "5bae632b1f69002c",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_2_AI3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI3",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":2,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "d2b8a91aee81bbd2",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_2_AI4",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC2_AI4",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 840,
        "wires": [
            []
        ]
    },
    {
        "id": "2ae0af8f7862a3f3",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI5",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI5",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":6,\"quantity\":1}",
        "payloadType": "json",
        "x": 710,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "f640daeaeb10e0b6",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1540,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "e91321157df47c6a",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 650,
        "y": 1500,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "424252db1ddad2e6",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 870,
        "y": 1620,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "ca69ac29a4bc8759",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 1740,
        "wires": [
            [
                "7f618a8ae0582fb0"
            ],
            [],
            [
                "a4b94911743d7356"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "a15aeace28a5ac33",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 640,
        "y": 1460,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "8ec7b1cd8c68062b",
        "type": "link in",
        "z": "cf449ce1322fd8eb",
        "name": "link in 56",
        "links": [],
        "x": 685,
        "y": 1420,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "a4b94911743d7356",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "42d828a7d63309fb",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 580,
        "y": 1740,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "f43b6bb0b654e6db",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor numérico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 1680,
        "wires": [
            [
                "369f074ba98950fb",
                "b6b27084a73de3f1"
            ]
        ]
    },
    {
        "id": "7f618a8ae0582fb0",
        "type": "modbus-flex-getter",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1090,
        "y": 1700,
        "wires": [
            [
                "424252db1ddad2e6",
                "9f18580871df255f"
            ],
            []
        ]
    },
    {
        "id": "9f18580871df255f",
        "type": "switch",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1320,
        "y": 1680,
        "wires": [
            [],
            [
                "f43b6bb0b654e6db",
                "4eecad812182fc46"
            ],
            []
        ]
    },
    {
        "id": "ec6fbae4caa74019",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "telemetria",
        "func": "msg.payload = {\n  flujo: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2320,
        "y": 1620,
        "wires": [
            []
        ]
    },
    {
        "id": "369f074ba98950fb",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1700,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "dbd9f49e2a572e0c",
        "type": "ui-chart",
        "z": "cf449ce1322fd8eb",
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02 1",
        "label": "Volumen FA-02 1",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 2010,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "b6b27084a73de3f1",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1850,
        "y": 1680,
        "wires": [
            [
                "dbd9f49e2a572e0c"
            ]
        ]
    },
    {
        "id": "27acebd6fccee10c",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 720,
        "y": 1300,
        "wires": [
            [
                "310eeb33d4324703"
            ]
        ]
    },
    {
        "id": "8d83d24e6fa3ee64",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "inject1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 720,
        "y": 1340,
        "wires": [
            [
                "b10ff3f6aca3195f"
            ]
        ]
    },
    {
        "id": "310eeb33d4324703",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "set flow.flags",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 900,
        "y": 1300,
        "wires": [
            []
        ]
    },
    {
        "id": "b10ff3f6aca3195f",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "set flow.registers",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 920,
        "y": 1340,
        "wires": [
            []
        ]
    },
    {
        "id": "210420523658be70",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 600,
        "y": 1620,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "b1afe634f11e8770",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 600,
        "y": 1660,
        "wires": [
            [
                "ca69ac29a4bc8759"
            ]
        ]
    },
    {
        "id": "477ad3560ea84fc1",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "name": "Flujo COPE 1",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE 1",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2310,
        "y": 1580,
        "wires": []
    },
    {
        "id": "4eecad812182fc46",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Acumulación de Datos y Detección de Estado",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst INICIO_AUMENTO_KEY = \"inicioAumento\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction detectarInicioAumento(cola, umbralAlcanzado) {\n    for (let i = cola.length - 1; i > 0; i--) {\n        if (cola[i].volumen <= cola[i-1].volumen) {\n            return { tiempo: cola[i].tiempo, indice: i };\n        }\n        if (cola[i].tiempo <= umbralAlcanzado) {\n            return { tiempo: cola[i].tiempo, indice: i };\n        }\n    }\n    return { tiempo: cola[0].tiempo, indice: 0 };\n}\n\nfunction calcularPromedioAnterior(cola, indiceInicio) {\n    const lecturasPrevias = cola.slice(0, indiceInicio);\n    if (lecturasPrevias.length === 0) return 0;\n    const suma = lecturasPrevias.reduce((acc, lectura) => acc + lectura.volumen, 0);\n    return suma / lecturasPrevias.length;\n}\n\nfunction detectarCambioVolumen(ultimoVolumen, nuevoVolumen) {\n    if (nuevoVolumen > ultimoVolumen + 70) return \"rellenando\";\n    if (nuevoVolumen < ultimoVolumen - 5) return \"vaciando\";\n    return \"estable\";\n}\n\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\nlet inicioAumento = flow.get(INICIO_AUMENTO_KEY) || null;\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || msg.payload;\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\nconst nuevoEstado = detectarCambioVolumen(ultimoVolumen, nuevaLectura.volumen);\n\nif (nuevoEstado === \"rellenando\" && estadoTanque !== \"rellenando\") {\n    const { tiempo: tiempoInicio, indice: indiceInicio } = detectarInicioAumento(colaLecturas, nuevaLectura.tiempo);\n    inicioAumento = tiempoInicio;\n    flow.set(INICIO_AUMENTO_KEY, inicioAumento);\n    \n    valorFijo = calcularPromedioAnterior(colaLecturas, indiceInicio);\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n    \n    colaLecturas = colaLecturas.slice(0, indiceInicio);\n} else if (nuevoEstado === \"vaciando\" && estadoTanque !== \"vaciando\") {\n    // Iniciar nueva cola al comenzar a vaciar\n    colaLecturas = [];\n    inicioAumento = null;\n    flow.set(INICIO_AUMENTO_KEY, null);\n    valorFijo = 0;\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n}\n\nestadoTanque = nuevoEstado;\nflow.set(ESTADO_TANQUE_KEY, estadoTanque);\n\nif (estadoTanque !== \"rellenando\") {\n    // Añadir la nueva lectura\n    colaLecturas.push(nuevaLectura);\n    \n    // Mantener solo los últimos 5 minutos de datos\n    const cincoMinutosAtras = Date.now() - 5 * 60 * 1000;\n    colaLecturas = colaLecturas.filter(lectura => lectura.tiempo >= cincoMinutosAtras);\n}\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\nflow.set(ULTIMO_VOLUMEN_KEY, nuevaLectura.volumen);\n\nreturn { payload: { colaLecturas, estadoTanque, valorFijo } };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1600,
        "wires": [
            [
                "76600a253c295e6a"
            ]
        ]
    },
    {
        "id": "76600a253c295e6a",
        "type": "switch",
        "z": "cf449ce1322fd8eb",
        "name": "Estado del Tanque",
        "property": "payload.estadoTanque",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "vaciando",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "rellenando",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1760,
        "y": 1600,
        "wires": [
            [
                "32cb813eb69ca339"
            ],
            [
                "18877a428c145d41"
            ]
        ]
    },
    {
        "id": "32cb813eb69ca339",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Cálculo de Flujo (Vaciado)",
        "func": "function calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nconst { colaLecturas } = msg.payload;\n\nlet flujo = calcularFlujo(colaLecturas);\n\nreturn { payload: flujo, estadoTanque: \"vaciando\" };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 1580,
        "wires": [
            [
                "477ad3560ea84fc1",
                "ec6fbae4caa74019"
            ]
        ]
    },
    {
        "id": "18877a428c145d41",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Cálculo de Flujo (Rellenado)",
        "func": "const { valorFijo } = msg.payload;\n\nreturn { payload: valorFijo, estadoTanque: \"rellenando\" };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 1620,
        "wires": [
            [
                "477ad3560ea84fc1",
                "ec6fbae4caa74019"
            ]
        ]
    },
    {
        "id": "739b7126e12f6d5a",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Procesamiento Unificado",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction detectarCambioVolumen(ultimoVolumen, nuevoVolumen) {\n    if (nuevoVolumen > ultimoVolumen + 70) return \"rellenando\";\n    if (nuevoVolumen < ultimoVolumen - 5) return \"vaciando\";\n    return \"estable\";\n}\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = ((primerRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n    const volumenFinal = ((ultimoRegistro.volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600);\n    }\n    return 0;\n}\n\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || msg.payload;\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\nconst nuevoEstado = detectarCambioVolumen(ultimoVolumen, nuevaLectura.volumen);\n\nif (nuevoEstado === \"rellenando\" && estadoTanque !== \"rellenando\") {\n    valorFijo = calcularFlujo(colaLecturas);\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n    colaLecturas = [];\n} else if (nuevoEstado === \"vaciando\" && estadoTanque === \"rellenando\") {\n    colaLecturas = [];\n    valorFijo = 0;\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n}\n\nestadoTanque = nuevoEstado;\nflow.set(ESTADO_TANQUE_KEY, estadoTanque);\n\nif (estadoTanque !== \"rellenando\") {\n    colaLecturas.push(nuevaLectura);\n    if (colaLecturas.length > 60) { // Mantener máximo 5 minutos de datos (asumiendo una lectura por segundo)\n        colaLecturas.shift();\n    }\n}\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\nflow.set(ULTIMO_VOLUMEN_KEY, nuevaLectura.volumen);\n\nlet flujo = estadoTanque === \"rellenando\" ? valorFijo : calcularFlujo(colaLecturas);\n\nreturn { payload: flujo, estadoTanque: estadoTanque };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 2040,
        "wires": [
            [
                "0a3e9d7ce25017e8"
            ]
        ]
    },
    {
        "id": "0a3e9d7ce25017e8",
        "type": "delay",
        "z": "cf449ce1322fd8eb",
        "name": "Rate Limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "5",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 1860,
        "y": 2040,
        "wires": [
            [
                "95f45d8c5ec582f1"
            ]
        ]
    },
    {
        "id": "95f45d8c5ec582f1",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "name": "Flujo COPE 2",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE 2",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 2100,
        "y": 2020,
        "wires": []
    },
    {
        "id": "224cd9f7384a2a68",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 820,
        "y": 2080,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "1d81203667db302d",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 2200,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "366cb2796a98e886",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1110,
        "y": 2080,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "afb2dfa2e5c537eb",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 2200,
        "wires": [
            [
                "9ccb484b7aca3e86"
            ],
            [],
            [
                "6c2fac3e1a695d44"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "6cb1493962f617dd",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 630,
        "y": 2200,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "6c2fac3e1a695d44",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 2220,
        "wires": [
            []
        ]
    },
    {
        "id": "09ebe9e923a9f253",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 820,
        "y": 2200,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "9ccb484b7aca3e86",
        "type": "modbus-flex-getter",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1330,
        "y": 2160,
        "wires": [
            [
                "366cb2796a98e886",
                "ae7bb35aa7c03c8f"
            ],
            []
        ]
    },
    {
        "id": "cac7595402665978",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 800,
        "y": 2120,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "2287b93e64b2f3a8",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 800,
        "y": 2160,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "ae7bb35aa7c03c8f",
        "type": "switch",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1560,
        "y": 2140,
        "wires": [
            [],
            [
                "85a5a93d9c74c0dc",
                "739b7126e12f6d5a"
            ],
            []
        ]
    },
    {
        "id": "85a5a93d9c74c0dc",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor numérico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1800,
        "y": 2140,
        "wires": [
            [
                "d3a4cc75a9339b75",
                "3cd770d4dcead9a4"
            ]
        ]
    },
    {
        "id": "d3a4cc75a9339b75",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1940,
        "y": 2140,
        "wires": [
            []
        ]
    },
    {
        "id": "3cd770d4dcead9a4",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2090,
        "y": 2140,
        "wires": [
            [
                "1d81862aeac9e116"
            ]
        ]
    },
    {
        "id": "1d81862aeac9e116",
        "type": "ui-chart",
        "z": "cf449ce1322fd8eb",
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02 2",
        "label": "Volumen FA-02 2",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 2250,
        "y": 2140,
        "wires": [
            []
        ]
    },
    {
        "id": "fb25f7ae8df89b08",
        "type": "link in",
        "z": "cf449ce1322fd8eb",
        "name": "link in 57",
        "links": [],
        "x": 715,
        "y": 2200,
        "wires": [
            [
                "afb2dfa2e5c537eb"
            ]
        ]
    },
    {
        "id": "d57376a9f5f1afbc",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Acumulación de Datos y Detección de Estado",
        "func": "const COLA_LECTURAS_KEY = \"colaLecturas\";\nconst ESTADO_TANQUE_KEY = \"estadoTanque\";\nconst INICIO_AUMENTO_KEY = \"inicioAumento\";\nconst ULTIMO_VOLUMEN_KEY = \"ultimoVolumen\";\nconst VALOR_FIJO_KEY = \"valorFijo\";\n\nfunction detectarInicioAumento(cola, umbralAlcanzado) {\n    let inicioDetectado = false;\n    for (let i = cola.length - 1; i > 0; i--) {\n        if (inicioDetectado) {\n            // Discard readings that break the pattern\n            if (cola[i].volumen >= cola[i - 1].volumen) {\n                return { tiempo: cola[i].tiempo, indice: i };\n            }\n        }\n        if (cola[i].tiempo <= umbralAlcanzado) {\n            inicioDetectado = true;\n        }\n    }\n    return { tiempo: cola[0].tiempo, indice: 0 }; // fallback if no increase is found\n}\n\nfunction calcularPromedioAnterior(cola, indiceInicio) {\n    const lecturasValidas = cola.slice(0, indiceInicio).filter((lectura, i, arr) => {\n        return i === 0 || lectura.volumen < arr[i - 1].volumen; // Filter out increasing values\n    });\n    \n    if (lecturasValidas.length === 0) return 0; // Fallback if no valid readings\n    const suma = lecturasValidas.reduce((acc, lectura) => acc + lectura.volumen, 0);\n    return suma / lecturasValidas.length;\n}\n\nfunction detectarCambioVolumen(ultimoVolumen, nuevoVolumen) {\n    if (nuevoVolumen > ultimoVolumen + 70) return \"rellenando\";\n    if (nuevoVolumen < ultimoVolumen - 5) return \"vaciando\";\n    return \"estable\";\n}\n\nlet colaLecturas = flow.get(COLA_LECTURAS_KEY) || [];\nlet estadoTanque = flow.get(ESTADO_TANQUE_KEY) || \"vaciando\";\nlet inicioAumento = flow.get(INICIO_AUMENTO_KEY) || null;\nlet ultimoVolumen = flow.get(ULTIMO_VOLUMEN_KEY) || msg.payload;\nlet valorFijo = flow.get(VALOR_FIJO_KEY) || 0;\n\nconst nuevaLectura = {\n    tiempo: Date.now(),\n    volumen: msg.payload\n};\n\nconst nuevoEstado = detectarCambioVolumen(ultimoVolumen, nuevaLectura.volumen);\n\nif (nuevoEstado === \"rellenando\" && estadoTanque !== \"rellenando\") {\n    const { tiempo: tiempoInicio, indice: indiceInicio } = detectarInicioAumento(colaLecturas, nuevaLectura.tiempo);\n    inicioAumento = tiempoInicio;\n    flow.set(INICIO_AUMENTO_KEY, inicioAumento);\n    \n    valorFijo = calcularPromedioAnterior(colaLecturas, indiceInicio);\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n    \n    colaLecturas = colaLecturas.slice(0, indiceInicio);\n} else if (nuevoEstado === \"vaciando\" && estadoTanque !== \"vaciando\") {\n    // Iniciar nueva cola al comenzar a vaciar\n    colaLecturas = [];\n    inicioAumento = null;\n    flow.set(INICIO_AUMENTO_KEY, null);\n    valorFijo = 0;\n    flow.set(VALOR_FIJO_KEY, valorFijo);\n}\n\nestadoTanque = nuevoEstado;\nflow.set(ESTADO_TANQUE_KEY, estadoTanque);\n\nif (estadoTanque !== \"rellenando\") {\n    // Añadir la nueva lectura\n    colaLecturas.push(nuevaLectura);\n    \n    // Mantener solo los últimos 5 minutos de datos\n    const cincoMinutosAtras = Date.now() - 5 * 60 * 1000;\n    colaLecturas = colaLecturas.filter(lectura => lectura.tiempo >= cincoMinutosAtras);\n}\n\nflow.set(COLA_LECTURAS_KEY, colaLecturas);\nflow.set(ULTIMO_VOLUMEN_KEY, nuevaLectura.volumen);\n\nreturn { payload: { colaLecturas, estadoTanque, valorFijo } };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 2480,
        "wires": [
            [
                "9c87b1cfc702bd43"
            ]
        ]
    },
    {
        "id": "9c87b1cfc702bd43",
        "type": "switch",
        "z": "cf449ce1322fd8eb",
        "name": "Estado del Tanque",
        "property": "payload.estadoTanque",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "vaciando",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "rellenando",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1390,
        "y": 2480,
        "wires": [
            [
                "5b654fd66acc75d8"
            ],
            [
                "2cb971558064e775"
            ]
        ]
    },
    {
        "id": "5b654fd66acc75d8",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Cálculo de Flujo (Vaciado)",
        "func": "function scaleVolume(volumen) {\n    return ((volumen - 4000) / (20000 - 4000)) * (40000 - 0);\n}\n\nfunction calcularFlujo(cola) {\n    if (cola.length < 2) return 0;\n\n    const primerRegistro = cola[0];\n    const ultimoRegistro = cola[cola.length - 1];\n    const tiempoDiferencia = (ultimoRegistro.tiempo - primerRegistro.tiempo) / 1000; // en segundos\n\n    const volumenInicial = scaleVolume(primerRegistro.volumen);\n    const volumenFinal = scaleVolume(ultimoRegistro.volumen);\n\n    if (tiempoDiferencia > 0 && volumenInicial > volumenFinal) {\n        return Math.round(((volumenInicial - volumenFinal) / tiempoDiferencia) * 3600); // Litros por hora\n    }\n    return 0;\n}\n\nconst { colaLecturas } = msg.payload;\n\nlet flujo = calcularFlujo(colaLecturas);\n\nreturn { payload: flujo, estadoTanque: \"vaciando\" };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 2460,
        "wires": [
            [
                "ad29b4a4a1553c29"
            ]
        ]
    },
    {
        "id": "2cb971558064e775",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Cálculo de Flujo (Rellenado)",
        "func": "const { valorFijo } = msg.payload;\n\nreturn { payload: valorFijo, estadoTanque: \"rellenando\" };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 2500,
        "wires": [
            [
                "ad29b4a4a1553c29"
            ]
        ]
    },
    {
        "id": "ad29b4a4a1553c29",
        "type": "ui-gauge",
        "z": "cf449ce1322fd8eb",
        "name": "Flujo COPE 3",
        "group": "3f690bb5a526a246",
        "order": 4,
        "width": "5",
        "height": "4",
        "gtype": "gauge-half",
        "gstyle": "rounded",
        "title": "Flujo COPE 3",
        "units": "L/h",
        "icon": "",
        "prefix": "",
        "suffix": "",
        "segments": [
            {
                "from": "0",
                "color": "#ea5353"
            },
            {
                "from": "4000",
                "color": "#5cd65c"
            },
            {
                "from": "7500",
                "color": "#ea5353"
            }
        ],
        "min": 0,
        "max": "10000",
        "sizeThickness": "26",
        "sizeGap": "3",
        "sizeKeyThickness": "20",
        "styleRounded": true,
        "styleGlow": false,
        "className": "",
        "x": 1940,
        "y": 2460,
        "wires": []
    },
    {
        "id": "66f01d635db2cc7d",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "update",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 460,
        "y": 2560,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "215153a99d55df18",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "next",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "next",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 2680,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "b834554e3a045c45",
        "type": "change",
        "z": "cf449ce1322fd8eb",
        "name": "Advance queue",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "next",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 750,
        "y": 2560,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "e336fe06d8d98977",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "Modbus Queue",
        "func": "let resendifnoresposne = true; // resend the last message is no response is received\nlet resendinterval = 10; // resend last e message every x seconds\nlet online_threshold = 10; // Seconds between updates under which the device is considered online\nlet offline_threshold = 300; // Seconds between updates above which the device is considered offline\n\nlet notifmsg = null;\n\n// Check and make sure the incoming message has a topic\nif ((msg.topic===\"\")||(msg.topic===null)||(msg.topic===undefined)) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Topic missing\"});\n    return;\n}\n\nlet lastupdate = context.get(\"lastupdate\");\nlet state = context.get(\"state\") | 0;\nlet queue = context.get(\"queue\");\nlet queuecount = 0;\nif (queue === undefined) {\n    queue = [];\n} else {\n    if (Array.isArray(queue)) {\n        queuecount = queue.length;\n    } else {\n        queue = [];\n    }\n}\nlet current = new Date().getTime();\nlet send = false;\n\nswitch (msg.topic.toLowerCase()) {\n    case \"update\":\n        // Update the timer and statistics\n\n        if (lastupdate !== undefined) {\n            notifmsg = { \"topic\": \"Information\", \"payload\": {} };\n            current = current - lastupdate;\n            current = Math.floor(current / 1000);\n            notifmsg.payload.secondsincelastupdate = current;\n            var minute = Math.floor(current / 60);\n            var hour = Math.floor(minute / 60);\n            var day = Math.floor(hour / 24);\n            if (current > 24 * 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + day + \" days, \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60 * 60) {\n                notifmsg.payload.updatetext = \"Last update \" + hour % 24 + \" hours, \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else if (current > 60) {\n                notifmsg.payload.updatetext = \"Last update \" + minute % 60 + \" minutes, \" + current % 60 + \" seconds ago\";\n            } else {\n                notifmsg.payload.updatetext = \"Last update \" + current % 60 + \" seconds ago\";\n            }\n\n            // Resend last message if there is no response from the server\n            if (resendifnoresposne) {\n                if ((current>0) && (current % resendinterval===0)) {\n                    let lastmsg = context.get(\"lastmsg\");\n                    if ((lastmsg!==undefined) && (context.get(\"sent\"))) {\n                        notifmsg.payload.resend = true;\n                        if ((lastmsg.payload.fc === 1) || (lastmsg.payload.fc === 2) || (lastmsg.payload.fc === 3) || (lastmsg.payload.fc === 4)) {\n                            // this is a modbus read request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Read re-sent!\" });\n                            return [lastmsg, null, notifmsg];\n                        } else {\n                            // this is a modbus write request\n                            node.status({ fill: \"green\", shape: \"dot\", text: \"Write re-sent!\" });\n                            return [null, lastmsg, notifmsg];\n                        }\n                    }\n                }\n            }\n\n            // Check for online state\n            if (state !== 1) {\n                if (current < online_threshold) {\n                    notifmsg.topic = \"Warning\";\n                    notifmsg.payload.text = \"Device is now online\";\n                    notifmsg.payload.statuschange = true;\n                    state = 1;\n                    context.set(\"state\", state);\n                }\n            } else {\n                if (current > offline_threshold) {\n                    notifmsg.topic = \"Error\";\n                    notifmsg.payload.text = \"Device is not transmitting\";\n                    notifmsg.payload.statuschange = true;\n                    state = 99;\n                    context.set(\"state\", state);\n                }\n            }\n            notifmsg.payload.state = state;\n            if (state===1) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: queuecount+ \" | \"+notifmsg.payload.updatetext });\n            } else {\n                node.status({ fill: \"red\", shape: \"ring\", text: queuecount + \" | \" + notifmsg.payload.updatetext });\n            }\n            return [null, null, notifmsg];\n\n        } else {\n            node.status({ fill: \"grey\", shape: \"ring\", text: \"No data\" });\n        }\n        break;\n    case \"next\":\n        // Update the lastupdate counter\n        context.set(\"lastupdate\", current);\n        context.set(\"sent\", false);\n        send = true;\n        break;\n    case \"reset\":\n        context.set(\"queue\",[]);\n        context.set(\"sent\", false);\n        context.set(\"lastmsg\", undefined);\n        break;\n    default:\n        // The incoming message is a modbus request\n\n        // delete the last msg to prevent from being resent\n        // context.set(\"lastmsg\", undefined);\n\n        // Check if there is already a message in the queue with the same topic. \n        // If there is it needs to be deleted, because we only keep the last message.\n        for (let i=queue.length-1; i>=0; i--) {\n            if (queue[i].topic === msg.topic) {\n                queue.splice(i,1);\n            }\n        }\n\n        // Add the message to the end of the queue\n        queue.push(msg);\n        context.set(\"queue\",queue);\n\n        if (!context.get(\"sent\")) {\n            send = true;\n        }\n        node.status({ fill: \"green\", shape: \"dot\", text: queue.length });\n\n}\n\n// We need to send out a new message\nif (send) {\n\n    if (queue.length>0) {\n        // Get the older message from the array\n        let newmsg = queue[0];\n        // remove this message\n        queue.splice(0,1);\n        context.set(\"queue\",queue);\n        context.set(\"sent\", true);\n        context.set(\"lastmsg\", newmsg);\n\n        if ((newmsg.payload.fc === 1) || (newmsg.payload.fc === 2) || (newmsg.payload.fc === 3) || (newmsg.payload.fc === 4)) {\n            // this is a modbus read request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Read sent!\" });\n            return[newmsg,null,null];\n        } else {\n            // this is a modbus write request\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Write sent!\" });\n            return [null, newmsg, null];\n        }\n        \n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 2680,
        "wires": [
            [
                "ad54997a38c9dc8b"
            ],
            [],
            [
                "3cccbdcf5a9e9253"
            ]
        ],
        "info": "# Modbus Queue\r\n\r\nThis node queueing read and write messages for modbus. Use this node if you are reading and writing the same device with many different requests. E.g. reading different coil/register intervals continously and also writing to the device at the same time.\r\n\r\nIt does a few things:\r\n- queues all messages arrive on the input port\r\n- based on the msg.topic, older messages of the same topci is ignored\r\n- sends out the oldest message and waits for the \r\n- monitors the time since last message and send out report on the output\r\n- handles online/offline status\r\n- resend the last message is response is not received in time\r\n\r\n## Input Data\r\n\r\n### payload\r\n\r\nThe payload should contain the data that gets sent to the flex-getter or flex-write node.\r\nTypical modbus read payload:\r\n`{\"value\":0,\"fc\":3,\"unitid\":1,\"address\":1000,\"quantity\":20}`\r\nTypical modbus write payload:\r\n`{\"value\":false,\"fc\":5,\"unitid\":1,\"address\":0,\"quantity\":1}`\r\n\r\n### topic\r\n\r\nEach message must contain a topic (any text), and this topic is used to identify the different read/write requests and delete any earlier request with the same topic if it still in the queueing\r\n\r\nThere are a few reserved topic for special function (for these payload is ignored):\r\n- reset: resets the queue and deleted any data collected so far\r\n- next: this is the message fed back from the flex getter/write node to indicate to this node that a new message can be sent out\r\n- update: this should be coming from a 1 second time to display the current queue count, time since the last update and online/offline status\r\n\r\n## Output ports\r\n\r\n### Port 1: flex getter\r\n\r\nThis output should be connected to a modbos-flex-getter and all the read requests will be sent out through this port\r\n\r\n### Port 2: flex write\r\n\r\nThis output should be connected to a modbos-flex-write and all the write requests will be sent out through this port\r\n\r\n### Port 3: status messages\r\n\r\nThis port outputs a status message for every update message (msg.topic=\"update\").\r\n\r\n- topic: \"Information\" for regular updates, \"Warning\": offline device is now back online, \"Error\": device is offline\r\n- payload.text: message like when the device gone offline, or back online\r\n- payload.updatetext: time passed since the last update (human readable format)\r\n- payload.secondsincelastupdate: number of seconds since the last update from the device\r\n- payload.statuschange: true if status is changed (gone offline, back online)\r\n- payload.state: 0: initial state, no data yet, 1: device online, 99: device offline\r\n\r\n## Node Settings\r\n\r\nChange the settings in the first 4 lines of the code to influence the behaviour. Explanation is in the code as comment."
    },
    {
        "id": "56a50c1afe9c2ca2",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "update",
        "payload": "",
        "payloadType": "date",
        "x": 270,
        "y": 2680,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "3cccbdcf5a9e9253",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "update log",
        "func": "if (msg.topic === \"Information\") {\n    // Registrar mensajes de información\n    node.log(\"Información: \" + msg.payload.updatetext);\n} else if (msg.topic === \"Warning\") {\n    // Registrar mensajes de advertencia\n    node.warn(\"Advertencia: \" + msg.payload.text);\n} else if (msg.topic === \"Error\") {\n    // Registrar mensajes de error\n    node.error(\"Error: \" + msg.payload.text);\n}\n\n// Puedes agregar lógica adicional para procesar otros campos del mensaje de estado\n// Por ejemplo, puedes verificar el valor de msg.payload.state para realizar acciones específicas\n// según el estado del dispositivo (en línea, fuera de línea, etc.)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 2700,
        "wires": [
            []
        ]
    },
    {
        "id": "62849a10392cbba2",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 460,
        "y": 2680,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "ad54997a38c9dc8b",
        "type": "modbus-flex-getter",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "0274315f4b847684",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 970,
        "y": 2640,
        "wires": [
            [
                "b834554e3a045c45",
                "a4401949977fed93"
            ],
            []
        ]
    },
    {
        "id": "fc7813fd664956e1",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI0",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI0",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":0,\"quantity\":1}",
        "payloadType": "json",
        "x": 440,
        "y": 2600,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "e2dbbb2ff4599739",
        "type": "inject",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1_AI1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "read_ADC1_AI1",
        "payload": "{\"value\":0,\"fc\":4,\"unitid\":1,\"address\":1,\"quantity\":1}",
        "payloadType": "json",
        "x": 440,
        "y": 2640,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "b378a6a649c5d213",
        "type": "link in",
        "z": "cf449ce1322fd8eb",
        "name": "link in 58",
        "links": [],
        "x": 355,
        "y": 2680,
        "wires": [
            [
                "e336fe06d8d98977"
            ]
        ]
    },
    {
        "id": "a4401949977fed93",
        "type": "switch",
        "z": "cf449ce1322fd8eb",
        "name": "ADC_1 Registers",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "read_ADC1_AI0",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "read_ADC1_AI2",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1200,
        "y": 2620,
        "wires": [
            [],
            [
                "68a64d5ae52ba853",
                "d57376a9f5f1afbc"
            ],
            []
        ]
    },
    {
        "id": "68a64d5ae52ba853",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "calc_vol",
        "func": "const valorCrudo = msg.payload[0];\nconst valorLitros = ((valorCrudo - 4000) / (20000 - 4000)) * (40000 - 0);\nmsg.payload = Math.round(valorLitros);  // Mantener solo el valor numérico\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 2620,
        "wires": [
            [
                "ac7d617096ee967e",
                "268458d15665823b"
            ]
        ]
    },
    {
        "id": "ac7d617096ee967e",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "telemetria",
        "func": "msg.payload = {\n  volumen: msg.payload\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1580,
        "y": 2620,
        "wires": [
            []
        ]
    },
    {
        "id": "268458d15665823b",
        "type": "function",
        "z": "cf449ce1322fd8eb",
        "name": "formato_ui",
        "func": "msg.payload = {\n    value: msg.payload,\n    label: msg.payload + \" Litros\"\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1730,
        "y": 2620,
        "wires": [
            [
                "a5653adc3ae42679"
            ]
        ]
    },
    {
        "id": "a5653adc3ae42679",
        "type": "ui-chart",
        "z": "cf449ce1322fd8eb",
        "group": "3f690bb5a526a246",
        "name": "Vol FA-02 3",
        "label": "Volumen FA-02 3",
        "order": 2,
        "chartType": "bar",
        "category": "label",
        "categoryType": "property",
        "xAxisProperty": "",
        "xAxisPropertyType": "msg",
        "xAxisType": "category",
        "yAxisProperty": "value",
        "ymin": "0",
        "ymax": "40000",
        "action": "replace",
        "pointShape": "circle",
        "pointRadius": 4,
        "showLegend": false,
        "removeOlder": 1,
        "removeOlderUnit": "3600",
        "removeOlderPoints": "",
        "colors": [
            "#227dbf",
            "#aec7e8",
            "#ff7f0e",
            "#2ca02c",
            "#98df8a",
            "#d62728",
            "#ff9896",
            "#9467bd",
            "#c5b0d5"
        ],
        "width": "1",
        "height": "5",
        "className": "",
        "x": 1890,
        "y": 2620,
        "wires": [
            []
        ]
    }
]